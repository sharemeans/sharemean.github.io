{"pages":[{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"代码简洁之道","text":"代码简洁之道这篇文章是从掘金上看到的，整理的很不错，故收藏，有比较大的参考价值传送门","link":"/2019/02/04/blogs/code-clean/"},{"title":"flex上中下布局","text":"此文档只是说明如何实现，采用最新的弹性盒子布局规范，对旧写法不做考虑。 盒子组成12345678910&lt;body class=&quot;flex-ver&quot;&gt; &lt;div class=&quot;header red&quot;&gt;header&lt;/div&gt; &lt;div class=&quot;container flex-auto orange&quot;&gt; &lt;div&gt;content&lt;/div&gt; &lt;div&gt;content&lt;/div&gt; &lt;div&gt;content&lt;/div&gt; &lt;div&gt;content&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer blue&quot;&gt;footer&lt;/div&gt;&lt;/body&gt; 步骤步骤一：body元素设置为flex容器，纵向主轴1234.flex-ver { display: flex; flex-direction: column;} 步骤二：header和footer固定高度123456.header { height: 150px;}.footer { height: 100px;} 步骤三：主体区域container设置为占用剩余高度1234.flex-auto { flex-grow: 1; flex-basis: 0%;} 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./flex.css&quot;&gt;&lt;/head&gt;&lt;body class=&quot;flex-ver&quot;&gt; &lt;div class=&quot;header red&quot;&gt;header&lt;/div&gt; &lt;div class=&quot;container flex-auto orange&quot;&gt; &lt;div&gt;content&lt;/div&gt; &lt;div&gt;content&lt;/div&gt; &lt;div&gt;content&lt;/div&gt; &lt;div&gt;content&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer blue&quot;&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;style&gt; .header { height: 150px; } .footer { height: 100px; } .flex-item { height: auto; } .flex { display: flex; flex-direction: row; } .flex-ver { display: flex; flex-direction: column; } .red { background: red; } .blue { background: blue; } .black { background: black; } .orange { background: orange; }&lt;/style&gt;&lt;/html&gt; 整体效果 主体内容高度自适应 底部footer位于文档最底部，即使主体区域高度不足以占满视口，footer依旧贴在底部。 兼容性火狐浏览器未能实现该效果，主体内容的高度根据内容自适应的，body的整体高度有可能低于视口高度。 解决火狐浏览器兼容性问题注意，html不要设置为overflow: hidden，要设置为overflow:visible。 12345678910html, body , div { padding: 0; margin: 0;}html { height: 100%;}body { min-height: 100%}","link":"/2019/05/10/blogs/flex-layout/"},{"title":"https密钥交换与数据传输","text":"https协议需要同事保证数据的私密性，也要保证完整性。也就是书，既要防止被解密，也要防止被篡改。 保证私密性私密性通过对称密钥加密来实现。所以，关键是要双方共享对称密钥（即下文的k），同时防止第三方拿到这个密钥。 双方共享对称密钥的过程即下图的“交换密钥”。 保证完整性虽然第三方没有办法解密截获的内容，但是它却可以对截获的内容进行篡改再发出去。https是如何做到识别篡改的呢？ https的加密算法含有消息认证机制。数字摘要是采用单项Hash函数将需要加密的明文“摘要”成一串固定长度（128位）的密文，这一串密文又称为数字指纹(fingerprint)，它有固定的长度，而且不同的明文摘要成密文，其结果总是不同的，而同样的明文其摘要必定一致。“数字摘要“是https能确保数据完整性和防篡改的根本原因。 所以只要对内容稍有改动，算出来的指纹就和原来的指纹不一样了，这样就可以知道内容已经被篡改过，不可信了。 所以，综上，双方是约定来一套机制验证数据的完整性，但是不能恢复被篡改的数据。","link":"/2020/10/02/blogs/https/"},{"title":"in 操作符","text":"用来判断对象中是否拥有某个属性。 使用场景for 循环12345let obj = {a: 1, b:2, c:3}for(let key in obj) { console.log(obj[key])} 判断是否有某个属性1234let obj = {a: 1, b:2, c:3}if('a' in obj) { console.log('obj has property &quot;a&quot;')} 和 hasOwnProperty的区别1in操作符可以判断所有可以通过点操作符访问到的属性，即可以访问对象本身以及原型链上的属性。hasOwnProperty只能判断实例拥有 的属性，不能判断原型链上的属性。 由于原型链上的属性是只读的，所以delete操作符只能删除属于对象本身的属性。","link":"/2020/03/20/blogs/in-operator/"},{"title":"linux常见命令","text":"查看端口占用情况 sudo netstat -apn | grep 80 最后一列可以看到进程号 查看ngin端口启用状态： ps -ef | grep nginx 查看端口进程上一步的进程号可以查出是哪个应用占用了端口 ps -ef | grep 3345 杀掉进程 sudo kill -9 3345 -9只是一个信号，表示强制终止，不管正在终止的进程在做什么 查看或编辑nginx配置12vi /usr/local/nginx/conf/nginx.confvi nginx.conf 重启服务器： /usr/local/nginx/sbin/nginx -s reload 连接远程服务器:ssh root@192.168.1.1 上传文件夹到远程目录：scp -r /usr/xxx root@192.168.1.1:/opt/project这个命令执行的结果是，xxx目录会存在于服务器project目录下 删除文件夹： rm -rf dist 移动所有文件到上一个目录： mv * ../ 查看当前目录： pwd 查看用户： cat /etc/passwd 查看用户组： cat /etc/group 查看用户属于哪个组： id root","link":"/2019/12/06/blogs/linux-command/"},{"title":"移动端meta","text":"viewport1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes,minimal-ui&quot;&gt; MobileOptimized告诉浏览器页面为某个宽度特殊优化 (微软系) 1&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot; /&gt; HandheldFriendly告诉浏览器页面是否为手持设备优化，会被MobileOptimized覆盖 (旧浏览器和功能机上某些浏览器识别) 1&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot; /&gt; Apple私有12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!-- iOS 设备 begin --&gt; &lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt; &lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt; &lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --&gt; &lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt; &lt;!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） --&gt; &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;/&gt; &lt;!-- 设置苹果工具栏颜色 --&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;/&gt; &lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt; &lt;!-- 启用360浏览器的极速模式(webkit) --&gt; &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; &lt;!-- 避免IE使用兼容模式 --&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt; &lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt; &lt;!-- 微软的老式浏览器 --&gt; &lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt; &lt;!-- uc强制竖屏 --&gt; &lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt; &lt;!-- QQ强制竖屏 --&gt; &lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt; &lt;!-- UC强制全屏 --&gt; &lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt; &lt;!-- QQ强制全屏 --&gt; &lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt; &lt;!-- UC应用模式 --&gt; &lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt; &lt;!-- QQ应用模式 --&gt; &lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt; &lt;!-- windows phone 点击无高光 --&gt; &lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt; &lt;!-- iOS 图标 begin --&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/apple-touch-icon-57x57-precomposed.png&quot;/&gt; &lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;/apple-touch-icon-114x114-precomposed.png&quot;/&gt; &lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;144x144&quot; href=&quot;/apple-touch-icon-144x144-precomposed.png&quot;/&gt; &lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt; &lt;!-- iOS 图标 end --&gt; &lt;!-- iOS 启动画面 begin --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;768x1004&quot; href=&quot;/splash-screen-768x1004.png&quot;/&gt; &lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1536x2008&quot; href=&quot;/splash-screen-1536x2008.png&quot;/&gt; &lt;!-- iPad 竖屏 1536x2008（Retina） --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1024x748&quot; href=&quot;/Default-Portrait-1024x748.png&quot;/&gt; &lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;2048x1496&quot; href=&quot;/splash-screen-2048x1496.png&quot;/&gt; &lt;!-- iPad 横屏 2048x1496（Retina） --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;/splash-screen-320x480.png&quot;/&gt; &lt;!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x960&quot; href=&quot;/splash-screen-640x960.png&quot;/&gt; &lt;!-- iPhone/iPod Touch 竖屏 640x960 (Retina) --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x1136&quot; href=&quot;/splash-screen-640x1136.png&quot;/&gt; &lt;!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) --&gt; &lt;!-- iOS 启动画面 end --&gt; &lt;!-- iOS 设备 end --&gt; format-detection禁用电话号码和邮箱识别 1&lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot; /&gt; 参考资料：移动端头部meta大全","link":"/2019/05/29/blogs/meta/"},{"title":"纯js实现打印功能","text":"打印其实最终都是调用window.print方法实现打印。只不过，我们通常不是打印整个页面，所以，诞生了各种各样的方法实现部分打印。适配vue框架的打印组件有vuePlugs_printjs和vue-print-nb。这两者实现的方式是一样的，都是使用iframe插入打印区域和对应样式。区别只是使用方式的区别。 那么，我也实现了一个原生js实现的打印功能。 一、新建iframe窗口为了打印出想要的部分，我们需要新建一个窗口，把需要的dom装进去。为了避免部分浏览器阻止窗口弹出导致无法打印，建议使用iframe。 打印的时候，我们需要防止iframe的显示影响页面布局，只需要在父页面设置iframe的样式为display: none即可。如下： 123const frame = document.createElement('iframe')frame.style.display = 'none'document.body.appendChild(frame) 二、选择需要打印的部分dom从当前dom选择需要打印的dom元素，插入iframe。 1234let target = document.getElementById('print-target')if (target) { frame.contentDocument.body.innerHTML = target.outerHTML} 三、插入样式一般情况下，你可以直接将父页面的style和link全部拷贝到iframe中，这样打印到样式和原本样式是一样的，除非打印部分的样式受未打印部分的父元素控制导致样式脱节，所以，打印部分的样式尽量和父元素解耦。 我们知道，浏览器打印的时候你可能需要不一样的样式，只需要加多一个style标签引入打印样式即可。比较典型的就是，打印的时候你想要按照需要打印的纸张尺寸打印，这时候可以在@media print中将容器的宽度改为打印尺寸（如A4是210mm，css支持mm单位的尺寸）。 四、特殊元素处理由于我们将打印区域拷贝到ifame中采用对的是将targetElement.outerHTML赋值给iframe的body的。这样赋值的情况下，部分表单组件会失去值，所以，我们需要在赋值之前将值固定，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041// https://github.com/Power-kxLee/vue-print-nb/blob/master/src/packages/printarea.jslet copy = ele.cloneNode(true);let copiedInputs = copy.querySelectorAll('input,select,textarea');let selectCount = -1;for (let i = 0; i &lt; copiedInputs.length; i++) { let item = copiedInputs[i]; let typeInput = item.getAttribute('type'); let copiedInput = copiedInputs[i]; // 获取select标签 if (!typeInput) { typeInput = item.tagName === 'SELECT' ? 'select' : item.tagName === 'TEXTAREA' ? 'textarea' : ''; } // 处理input框 if (item.tagName === 'INPUT') { // 除了单选框 多选框比较特别 if (typeInput === 'radio' || typeInput === 'checkbox') { copiedInput.setAttribute('checked', item.checked); // } else { copiedInput.value = item.value; copiedInput.setAttribute('value', item.value); } // 处理select } else if (typeInput === 'select') { selectCount ++; for (let b = 0; b &lt; ele.querySelectorAll('select').length; b++) { let select = ele.querySelectorAll('select')[b]; // 获取原始层每一个select !select.getAttribute('newbs') &amp;&amp; select.setAttribute('newbs', b) // 添加标识 if (select.getAttribute('newbs') == selectCount) { let opSelectedIndex = ele.querySelectorAll('select')[selectCount].selectedIndex; item.options[opSelectedIndex].setAttribute('selected', true); } } // 处理textarea } else{ copiedInput.innerHTML = item.value; copiedInput.setAttribute('html', item.value); }}","link":"/2019/08/20/blogs/print/"},{"title":"html property &amp; attribute","text":"propertyDOM元素的属性，如selectedIndex, tagName, nodeName, nodeType, ownerDocument, defaultChecked, defaultSelected DOM是提供给js访问页面元素的对象 attributeHTML标签上绑定的属性，包括id, value, name, type，除了value之外，其它属性基本都是字符串类型的 JQuery的attr()和prop()方法的区别prop()就是获取property属性的值，attr()是获取attribute的值如果要改变DOM的值，获取会发生变化的属性值，需要调用prop()方法，比如checked, selected, or disabled1&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt; 对于以上标签，获取值对应关系如下： 123456elem.checked true (Boolean) Will change with checkbox state$( elem ).prop( &quot;checked&quot; ) true (Boolean) Will change with checkbox stateelem.getAttribute( &quot;checked&quot; ) &quot;checked&quot; (String) Initial state of the checkbox; does not change$( elem ).attr( &quot;checked&quot; ) (1.6) &quot;checked&quot; (String) Initial state of the checkbox; does not change$( elem ).attr( &quot;checked&quot; ) (1.6.1+) &quot;checked&quot; (String) Will change with checkbox state$( elem ).attr( &quot;checked&quot; ) (pre-1.6) true (Boolean) Changed with checkbox state","link":"/2018/07/03/blogs/property-attribute/"},{"title":"proxy 与 reflect","text":"Proxy定义 在目标对象上架设一个拦截层， 外界对该对象的访问先经过这一个拦截层，这个拦截层可以对外界对访问进行过滤和改写。翻译为代理器。 举个拦截和改写例子： 12345678let proxy = new Proxy({}, { get: function() { return 35 }})proxy.time // 35proxy.name // 35 上面对代码拦截了一个空对象的属性getter。只要是需要访问到对象的属性，都会触发getter。 Proxy 能拦截哪些访问行为呢？ 拦截行为 触发条件 返回值说明 get(target, propKey, receiver) 读取对象属性，proxy.foo，proxy[‘foo’] 返回属性值 set(target, propKey, value, receiver) 设置对象属性，proxy.foo = v，proxy[‘foo’] = v 返回一个布尔值，表示是否设置成功 has(target, propKey) propKey in proxy的操作 返回一个布尔值，表示是否包含此属性 deleteProperty(target, propKey) delete proxy[propKey] 返回一个布尔值，表示是否删除成功 ownKeys(target) Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环 返回目标对象所有自身的属性的属性名 getOwnPropertyDescriptor(target, propKey) Object.getOwnPropertyDescriptor(proxy, propKey) 返回属性的描述对象 defineProperty(target, propKey, propDesc) Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs) 返回一个布尔值表示是否定义成功 preventExtensions(target) Object.preventExtensions(proxy) 返回一个布尔值表示是否定义成功 getPrototypeOf(target) Object.getPrototypeOf(proxy) 返回一个对象（对象原型） isExtensible(target) Object.isExtensible(proxy) 返回一个布尔值 setPrototypeOf(target, proto) Object.setPrototypeOf(proxy, proto) 返回一个布尔值 apply(target, object, args) 拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…) 无限制 construct(target, args) 拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args) 返回实例对象 Reflect定义 将Proxy支持的代理方法一一对应到Reflect，方便在Proxy中使用原对象的默认行为。 12345678910let proxy = new Proxy(target, { set: function(target, name, value, receiver) { var success = Reflect.set(target, name, value, receiver); if (success) { console.log('property ' + name + ' on ' + target + ' set to ' + value); } return success; }});proxy.a = 1 某些方法和Object原型方法行为高度一致，所以，除了在Proxy中使用，还可以单独使用。 1234567891011121314// 老写法try { Object.defineProperty(target, property, attributes); // success} catch (e) { // failure}// 新写法if (Reflect.defineProperty(target, property, attributes)) { // success} else { // failure} 谁在用Vue设置内置属性只读设置内置keyCode为只读： 123456789101112131415161718const hasProxy = typeof Proxy !== 'undefined' &amp;&amp; Proxy.toString().match(/native code/) if (hasProxy) { const isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact') config.keyCodes = new Proxy(config.keyCodes, { set (target, key, value) { if (isBuiltInModifier(key)) { warn(`Avoid overwriting built-in modifier in config.keyCodes: .${key}`) return false } else { target[key] = value return true } } }) } 1Vue.config.keyCodes.ctrl = 86 以上代码会报错： 测试框架和defineProperty什么关系？什么时候适合用？","link":"/2020/03/15/blogs/proxy-reflect/"},{"title":"正向代理和反向代理的区别","text":"正向代理位于客户端和服务器之间的代理服务器，对服务器不可见。 客户端可以访问该代理服务器，但是客户端不直接访问代理背后的服务器，或者客户端根本没办法访问代理背后的服务器。 客户端需要明确指定代理服务器的地址。以及可能需要身份认证来限制其它客户端随意访问。 正向代理比较常见的使用场景是翻墙，局域网抓包。 反向代理隐藏于服务器背后，对客户端不可见 客户端访问的服务器本身就是反向代理服务器，只是客户端不知情。反向代理服务器将客户端的请求代发给其背后的服务器，拿到结果并传回给客户端。 反向代理比较常见的场景是本地代码调试线上接口，表面访问本地接口，但是由本地反向代理服务器将接口转发到线上地址以解决接口跨域问题。另外一个常用的场景是服务器负载均衡，以及外网灰度发布。 外网灰度发布举个例子，反向代理负责将请求转发给3个服务器，这3个服务器上的代码有一个是旧版本，另外2个是新版本。代理服务器将某些ip段客户端的请求转发给旧版本，其它的转发给新版本。这样就可以达到灰度发布的效果。","link":"/2020/03/17/blogs/proxy/"},{"title":"有趣的正则表达式","text":"字符串拼接假设有这样一种场景： 有三个字符串类型的变量，姓名(name)，性别(sex)，年龄(age)。想把这三个变量值用逗号拼接成1个字符串userInfo。 常规的方法可能就是类似这样： 1let userInfo = `${name}，${sex}，${age}` 问题是，这三个变量可能都为空。你肯定不希望userInfo是”，，10”或者”小明，，10”或者”，，” 简单的思考后你可能会这样做： 1234let userInfo = ''name ? userInfo += name + '，' :sex ? userInfo += sex + '，':age ? userInfo += age + '，': 本着足够懒的想法，仔细考虑了一番之后，我总结出的规律就是： 开头结尾的连接符删除 中间有2个或以上的连接符都要删减至1个 所以可以这样写： 1let userInfo = `${name}，${sex}，${age}`.replace(/(^，)|(，$)/g, '').replace(/，{2,}/, '，')","link":"/2019/04/16/blogs/regexpression/"},{"title":"base64字符串保存","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt;//方法1function saveAsLink(base64Str) { var a = document.createElement('a'); // 转换完成，创建一个a标签用于下载 a.download = fileName; a.href = 'data:application/msword;base64,' + base64Str; a.style.display = 'none'; document.body.appendChild(a) // 修复firefox中无法触发click a.click(); document.body.removeChild(a)}saveAsLink(fileBse64Str)//方法2(firefox浏览器不兼容)var blob = new Blob([_base64ToArrayBuffer(fileBse64Str)], {type: 'application/msword'}), fileName = '文件名称.doc'function _base64ToArrayBuffer(base64) { var binary_string = window.atob(base64); var len = binary_string.length; var bytes = new Uint8Array( len ); for (var i = 0; i &lt; len; i++) { bytes[i] = binary_string.charCodeAt(i); } return bytes.buffer;}function downFile(blob, fileName) { if (window.navigator.msSaveOrOpenBlob) { navigator.msSaveBlob(blob, fileName); } else { var link = document.createElement('a'); debugger link.href = window.URL.createObjectURL(blob); link.download = fileName; link.click(); window.URL.revokeObjectURL(link.href); }}downFile(blob, fileName)&lt;/script&gt;&lt;/html&gt;","link":"/2020/05/08/blogs/save-base64/"},{"title":"防抖和节流","text":"防抖短时间内连续触发的事件，不执行回调，给定一个冷却时间，这段时间内没有触发则时间结束后执行回调。即，持续触发不执行，不触发一段时间之后再执行。 常见场景： 输入框持续输入，输入内容远程查询 多次触发点击事件 滚动后获取滚动距离 12345678910const debounce = function (func, delay) { let timer = null return function() { clearTimeout(timer) timer = setTimeout(() =&gt; { func(...arguments) }, delay || 300) }} 节流函数一段时间内只执行一次。即，持续触发并不会执行多次，到一定时间再去执行。通过闭包保存开关状态。常见场景： 自定义滚动条 页面resize 12345678910111213141516const throttle = function (func, delay) { let run = true return function () { if (!run) { // 如果开关关闭了，那就直接不执行下边的代码 return } // 持续触发的话，run一直是false，就会停在上边的判断那里 run = false func(...arguments) // 定时器到时间之后，会把开关打开，我们的函数就会被执行 setTimeout(() =&gt; { run = true }, delay) }} 以上方法使用的时候需要注意，由于返回的是函数，所以throttle或debounce只能调用一次。以Vue为例： 12345678910111213onPageScroll(e) { if (!this.$options.throttleFunc) { this.$options.throttleFunc = throttle((scrollTop) =&gt; { if(scrollTop &gt; 30) { this.scrollStatus = true } else { this.scrollStatus = false } }, 100) } this.$options.throttleFunc(e.scrollTop)} 参考资料:知乎：函数的防抖和节流是个啥？？？","link":"/2021/05/31/blogs/throttle-debounce/"},{"title":"nuxt导航共用","text":"导航作为多个页面之间共用的部分，一般是动态的，即每个页面返回之前需要异步请求。 服务端异步请求的方法有asyncData，fetch。但是这俩方法都只支持页面组件，不支持layout中使用。 所以，我们只能用vuex作为中转站，将页面组件获取的导航信息存储到vuex中。layout再从vuex中获取。 layout/default 1234567891011121314import navigator from '@@/navigator/index.vue'export default { name: 'Music163', components: { navigator }, data () { return { } }, computed: { menus () { return this.$store.state.menu.menus } }} pages/index 12345export default { fetch ({ store, params }) { store.dispatch('menu/GET_MENU') }} store/menu 123456789101112131415161718192021export const state = () =&gt; ({ menus: []})export const mutations = { SET_MENU (state, menus) { state.menus = menus }}export const actions = { GET_MENU (store, menus) { const data = [{ title: '发现音乐' }, { title: '我的音乐' }] store.commit('SET_MENU', data) }}","link":"/2020/01/20/nuxt/navigator/"},{"title":"一次技术方案的分析过程","text":"分析技术方案时，保持以终为始的原则。思维就像一棵树，方案就像树枝，遍历之后发现不可行，只需要往根部回溯，重新思考达到目标的其它方法。 背景这是我负责的一个H5项目，内嵌于APP的webview，页面跳转通过打开新的webview来实现类app的效果。 在app内从另外一个项目跳转到该应用时，需要带上一个sourceid，标记引流入口。sourceid可能是来源于首页或者商品详情页，只有在下单的时候会提交给订单。 任务对该sourceid生命周期的要求是： 外部项目跳转进入该项目之后，到关闭由它打开的所有页面为止，算一个生命周期。 行动从页面跳转传参入手app为和提供了桥接sdk，应用内webview调用的是同一个api，打开新窗口前可以使用proxy拦截该api，获取当前窗口的链接，将链接上的sourceid带到新窗口上，实现sourceid参数的透传。 这个方法简单粗暴，却有明显的缺点： 业务和工具耦合，不利于维护 分享转发前需要把该参数去掉，会影响到旧的逻辑 该方法可行，但是属于对公共代码的修改，容易引发bug，暂时纳入备选方案。 从本地存储方案入手浏览器本地缓存方案有localstorage、sessionStorage、cookie。这些方案在webview中是否也适用呢？ 经过在ios中验证localstorage的缓存行为和浏览器类似，sessionStorage和cookie在webview之间不共享，因此2者被排除。 请教了ios客户端的同事，了解到，ios平台的app目前使用的是WKwebview实现，窗口之间使用的是不同的WKProcessPool，所以数据共享是个问题，localstorage之所以看起来像是共享了，实际上只是在打开同源窗口时复制了一份，新开的窗口对localStorgae所做的修改不会对旧窗口有影响。这些问题在以前UIwebview开发的时代是不存在的，而UIwebview的是因为内存占用过高而逐渐被淘汰。 可共享的存储方案就只剩下localstorage。由于localstorage属于持久化存储，想要识别一次完整使用，需要抓住一个边界点：要如何识别一次完整使用，是否具有开始或者结束的标志。在这个边界点更新sourceid 完整使用的标志有： 该webview是应用中当前存在的唯一本项目的webview，标记一次使用的开始 应用中当前存在的唯一本项目的webview被销毁，标记一次使用的结束 这2种标志如何去标记呢？我想到了以下办法： app提供相关api告诉我们是否是同源webview的第一个页面，就像微信小程序那样，打开非首页的头部左上角会显示一个home按钮。很遗憾没有找到相关api。 像window.onbeforeunload那样监听页面销毁，存储过sourceid的页面在页面销毁前销毁缓存的sourceid。通俗来讲，就是自产自销（销毁）。经测试发现，webview关闭并不会触发window.onbeforeunload和onunload事件。该方法不可行。 不那么完美的实现方案当没有完美的解决方案时，问自己，我们真的一定要完美的实现吗？经过和产品的讨论，产品方认为，不需要。可以根据用户的使用习惯，大致确定sourceid的合理有效时间，通过localstorage实现超时清理方案。 结论又一个很简单的决策公式：决策 = 收益 - 成本 - 风险以下列出了暂时可行的方案评估表： 方案 收益 成本（开发） 风险（上线+后期维护） 决策 proxy拦截api添加参数 10 3 1+1 5 localstorage有效期 8 1 0+0 7 根据上表的结果，最终选择了“localstorage有效期”这个方案。","link":"/2021/05/10/think/fanganfenxi/"},{"title":"四象限时间管理","text":"史蒂芬·科维的《高效能人士的七个习惯》在描述如何实现个人领域成功时提到了一个很重要的习惯，“要事第一”。 通常我们列出来的TODO list是线性的，从上至下排列，我们的评判标准只有一个：是否重要。 一、2个维度 4个象限2个维度： 是否重要 重要性对一个人来说要从价值观的角度去考虑。这件事做了之后是否有收获，这个收获一定要对自己有意义。 通常大家觉得，让自己有收获的事情才是最重要的。我觉得，工作期间和工作之余要区分开来。即在该做什么事情的时候就做什么事情。所以，针对工作和生活可以使用2份4象限表。 是否紧急 在近期内必须要完成的，即紧急的 一般比较紧急的是有deadline的事情。 工作上的例子：项目上线，会议前的方案搜集 生活中的例子：上学，煮饭 4个象限： 重要且紧急 重要不紧急 不重要但紧急 不重要不紧急。 二、如何区分事件属于哪个象限？以下针对4个象限的界定标准进行描述。 重要&amp;紧急 (Urgent &amp; Important)这个象限内的事情可以说不得不做。生活中应该尽量避免堆积太多此类事情，否则整日焦头烂额。 不立即做的话将来随时可能产生危机 必须在deadline之前赶出来，这个deadline强调外界压力 重要&amp;不紧急 (Important &amp; Not Urgent) 有助于个人长远发展的事情， 比如学习计划，技术方案调研 有助于群体长远发展的事情，比如培训计划 有助于减少“重要紧急”事项的事情。 我们通常说，有拖延症的人通常指，把重要但是不紧急的事情拖延到演变为重要紧急的事情，导致花更多的时间在第一象限。 紧急&amp;不重要 (Urgent &amp; Not Important) 需要近期做的事情，迫不得已可以选择不做或者接受延期的 时间比较赶，但是不怎么耗费精力 这类工作最好做，但是在精力状态一般的情况下做，必要的时候选择不做。这样可以充分利用以及节约时间。这类事情包括约会，群体活动，回复邮件。 不重要&amp;不紧急 (Not Important &amp; Not Urgent) 纯粹打发时间，没有任何实际意义 短期精神满足，实则空虚 这类事情在其它象限的事情没有处理完的时候尽量不要做。除非其它象限的事情完全没有精力做下去了又不想休息。 三、如何实施1、针对列出的任务清单，问自己2个问题： 这件事情，真的很重要吗？如果是工作任务，是否属于高优先级的任务？如果是学习任务，是否能让自己有所收获？所需要的时间是多久？ 通过以上问题，把任务分成重要和不重要的，相同类别下的任务分别赋值一个重要指数。 这件事情你自己计划或者上级需要什么时候完成？写下deadline，给自己定下的deadline最好比实际要求的更早。 通过以上问题，把最近1周内需要做的事情按照deadline进行排序，其它的事情暂时安排到下周。如果任务需要花的时间比较长，最好做一下任务分解，说不定可以分解出一些可以延后的任务。 2、针对排好的任务进行象限组合、排序把每个任务放到所属的象限内，并根据2个维度的指数进行象限内排序。 3、执行顺序大体上任务的执行顺序按照 重要&amp;紧急，重要&amp;不紧急，紧急&amp;不重要，不紧急不重要 的顺序来。 但是，如果你是替别人打工，有些工作上“不重要且紧急”的事情需要排在“重要&amp;不紧急”的事情前面，往往前者比后者更加耗时间，所以可以选择在前者的间隙处理后者。 4、每日调整&amp;总结安排总会因为各种原因变化，我们要重视对任务重新梳理的过程，以免做无用功。 不要每天给自己安排过多的任务，总结的时候发现没有按时完成任务会带来懊悔和自我否定。合理的安排比压榨自己更加划算。","link":"/2019/04/09/think/manage-time/"},{"title":"charles 重写请求","text":"charles 和fiddler既然都可以拦截返回体，没有理由不可以拦截请求是不是？ 我这里只说charles吧。 配置重写域名 进入菜单 Tools -&gt; Rewrite 可见如下界面 点击sets 区域的Add按钮添加重写任务。 在右侧的Locations区域点击Add按钮添加需要重写的请求的域名 配置域名下的重写规则 选中上一个步骤中添加的域名，在Rules区域点击Add按钮 在Type项那里选择重写类型 有以上几种类型可供选择。从上图可以看出来，重写规则可以重写请求头部和请求体，也可以重写返回头部和返回体。 这个功能不仅能调试身份认证信息，还能调试跨域网站，以及接口数据。 在Match和Replace区域配置重写规则 上图将请求头部uniType的值替换为105，仅当uniType的值为101的时候才替换。","link":"/2020/02/01/tools/charles-rewrite-header/"},{"title":"抓包工具调试线上代码","text":"web应用代码混淆和压缩可以一定程度上缩短代码的请求时间，从而提高页面的访问体验，但是却不方便调试。这里教大家使用抓包工具调试线上代码。 以下方法假设你已经成功用fiddler或者charles代理你要调试的线上应用。 fiddler拦截客户端代码很久以前遇到一个线上问题，本地不能复现，而且还是手机浏览器环境，而且客户端报错日志找不到相关的问题。当时想到的调试方法就是使用fiddler修改返回的js代码，开启vconsole的debug模式查看页面报错信息。这个方法其实就是拦截返回js并正则匹配内容进行修改。 局部修改使用fildder可以拦截http返回内容并修改。 1.打开CustomRules.js点击fiddler的Rules=&gt;Customize Rules，FiddlerScript editor工具就会自动的打开CustomRules.js文件。 2.修改 OnBeforeResponse 函数假如，我想把http://my.example.com/index.html 资源返回代码中的”vconsole.debug = false”改为”vconsole.debug = true”，只需要在这个函数中插入一个if语句。可以这样写： 12345//判断Url内容中是否包含特定内容，针对这个Url进行下面的操作if (oSession.uriContains(&quot;my.example.com/index.html&quot;)) { oSession.utilDecodeResponse(); oSession.utilReplaceInResponse(&quot;vconsole.debug = false&quot;, &quot;vconsole.debug = true&quot;);} 这个方法比较难操作，毕竟你需要先找到要修改的代码，确保需要替换的内容是独一无二的，而且，如果想修改替换内容需要重新修改替换逻辑。更加简单粗暴的方法是直接下载代码下来，将这个资源代理到本地，想怎么修改就怎么修改。 fiddler将代码代理到本地1.找到你需要代理的请求 标黄的请求就是目标请求，拖拽到右侧的AutoResponse标签中 2.选中代理选项勾选右侧AutoResponse标签中的 Enable rules：开启重定向使规则生效，指的是代理到本地这个规则。 Umatched requests passthrough:不影响那些没满足我们处理条件的请求通过。 3.选择需要代理的到的本地文件上图右侧选中第一步拖进去的请求，并在右下角的Rule Editor中的第二个下拉框选择Find a file。此时会打开本地资源管理器要求你选择文件。 4.修改代码刷新页面修改上一步你选中的代码，保存之后刷新你要调试的页面，重新加载的资源就回变成你本地的资源。 charles拦截客户端代码设置map local在请求中找到需要调试的代码文件，右键，菜单中选择 Map Local弹窗中选择需要映射到的本地文件点OK即可。 重新请求对应的资源发现已经是本地的代码文件了。这时候可以随意的修改代理到的本地文件调试。 取消map在Tools-&gt;Map Local菜单下可以删除刚刚添加的map。","link":"/2020/02/02/tools/fiddler-debug-online/"},{"title":"git 常用命令","text":"本地代码新建远程仓库如果本地配置的ssh 是其它域名下的，比如说公司内网gitlab，但是你此时想要创建的仓库是github上的，那代码推到远程仓库的时候需要使用https协议，而不是ssh，不然的话身份认证会失败的。 1git@github.com: Permission denied (publickey). 远程：创建一个仓库， 假如链接为 1https://github.com/sharemeans/vue.git/ 本地：12345678cd my-vuegit initgit add .git commit -m &quot;项目初始化&quot;git remote add origin https://github.com/sharemeans/vue.git/// 根据提示输入账号密码，成功之后代码自动上传// 代码推送到远程 -u表示推送成功后自动建立本地分支与远程分支的追踪git push -u origin master 查看远程仓库地址1git remote -v 查看本地分支跟踪的远程分支1git branch -vv 基于远程分支A创建本地跟踪分支A1git checkout -b A origin/A 基于本地分支B创建本地分支A1git checkout -b A B 基于远程分支创建本地同名跟踪分支1git checkout --track origin/A 合并A 分支到当前分支，且所有冲突都采用A分支1git pull -s recursive -X theirs A","link":"/2019/12/01/tools/git/"},{"title":"插件Pipeline: Groovy","text":"Jenkins 自动化构建基于一系列插件，常用的插件 最基础的是流水线插件。公司内的流水线插件配置使用Pipeline: Groovy。该插件的基本配置如下。 可以直接在文本框写入简单的脚本（Pipeline script），也可以读取Jenkinsfile内的流水线脚本（Pipeline script from scm）。scm全称是Source Control Management，如gitlab。 选择了SCM之后需要配置git的地址和账号密码： 选择构建分支： 构建分支BRANCH的值来源于参数，需要配置参数化构建，Jenkins可配置的参数类型有： 其中，Git Parameter类型需要安装插件：Git Parameter。 该插件获取以下类型的值，并赋值给我们定义的变量名BRANCH（可以是其它名字）： 分支选择时可以配置过滤器以及分支显示框的高度： 另外可以配置其它参数，如构建环境：checkbox类型的值传入Jenkinsfile中的格式为字符串，分隔符和Jenkins上的配置一致。 Jenkinsfile中可以通过params 获取到参数化构建中传入的参数： 选择构建分支时，可以使用参数化构建传入的参数： pipeline:Groovy可以配置构建执行脚本文件路径：","link":"/2021/04/30/tools/pipeline-groovy/"},{"title":"uni-app 小程序自定义图标组件","text":"图标组件支持的功能： 图标颜色 图标名称 图标边距 图标大小 事件类型 事件名称 事件描述 click 点击事件 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!--图标组件&lt;com-icons name=&quot;icon-location&quot; size=&quot;28rpx&quot; padding=&quot;0 10rpx&quot; color=&quot;#ffffff&quot;&gt;&lt;/com-icons&gt;--&gt;&lt;template&gt; &lt;text class=&quot;uni-icons iconfont&quot; :class=&quot;name&quot; :style=&quot;{ fontSize: size, color: color, padding: padding }&quot; @click=&quot;_onClick&quot;&gt;&lt;/text&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'uni-icons', props: { name: { // 图标类型，拼接前缀icon- type: String }, size: { // 图标大小 type: String, default: 'inherit' }, color: { // 图标颜色 type: String, default: 'inherit' }, padding: { // 内边距 type: String, default: '0' } }, methods: { _onClick() { this.$emit('click') } }}&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt; @import 'path-to/iconfont.less';&lt;/style&gt;","link":"/2020/11/20/uni-app/com-icons/"},{"title":"uni-app 小程序自定义导航栏组件","text":"该组件是基于uni-ui扩展组件uni-nav-bar修改。导航组件严格来说是有2个组件组成：状态栏组件，头部组件 getStatusBarHeight和getMenuButtonBoundingClientRect方法可以获取小程序状态栏和头部胶囊信息，取值关系如下： 需要注意的是，通过getMenuButtonBoundingClientRect方法top属性一般比getStatusBarHeight的值大，且不同设备具体差异大小不同。 关于状态栏组件，具体搜索文章小程序状态栏组件。 导航组件该组件依赖于以下组件： com-icons iconfont组件 com-status-bar 状态栏组件 以上组件可通过搜索名称查找相关代码。 导航组件具有以下功能： 滚动头部固定/跟随文档 自定义返回按钮、按钮后的文案、左侧/右侧区域宽度 头部固定时是否需要保持高度（避免业务方做高度兼容） 头部透明度（支持头部随着滚动过渡） 是否需要状态栏 自定义返回按钮点击行为 小程序环境自动判断是否需要显示回到首页按钮 事件类型 事件名称 事件描述 clickLeft 点击左侧区域 clickRight 点击右侧区域 方法 方法名称 方法描述 getHeight 获取导航高度 使用时需要修改以下功能： icon组件对应的icon字体需要根据具体的应用修改 HOME_PATH对应的值根据具体的应用修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413&lt;template&gt; &lt;view class=&quot;uni-navbar&quot;&gt; &lt;view :class=&quot;{ 'uni-navbar--fixed': fixed, 'uni-navbar--shadow': shadow, 'uni-navbar--border': border }&quot; :style=&quot;{ 'background': backgroundColor, opacity: opacity }&quot; class=&quot;uni-navbar__content&quot;&gt; &lt;com-status-bar v-if=&quot;statusBar&quot; /&gt; &lt;view :style=&quot;{ color: color,background: backgroundColor, height: headerHeight, lineHeight: headerHeight }&quot; class=&quot;uni-navbar__header uni-navbar__content_view&quot;&gt; &lt;!-- 左侧（默认点击行为：返回上一页。可重写） --&gt; &lt;view @click=&quot;onClickLeft&quot; class=&quot;uni-navbar__header-btns uni-navbar__header-btns-left uni-navbar__content_view&quot; :style=&quot;{width: leftIconWidth}&quot;&gt; &lt;!-- 回到首页按钮（分享场景）（与其它按钮或者文案互斥） --&gt; &lt;!-- #ifdef MP-WEIXIN --&gt; &lt;view class=&quot;uni-navbar__content_view&quot; :class=&quot;{'header-icon-with-bg': showIconBg}&quot; v-if=&quot;showHome&quot; @click=&quot;goHome&quot;&gt; &lt;com-icons :color=&quot;color&quot; name=&quot;icon132&quot; size=&quot;40rpx&quot; /&gt; &lt;/view&gt; &lt;!-- #endif --&gt; &lt;!-- 返回按钮 --&gt; &lt;view class=&quot;uni-navbar__content_view&quot; :class=&quot;{'header-icon-with-bg': showIconBg}&quot; v-if=&quot;!showHome &amp;&amp; leftIcon &amp;&amp; showLeftBack&quot; &gt; &lt;com-icons :color=&quot;color&quot; name=&quot;icon9&quot; size=&quot;40rpx&quot; /&gt; &lt;/view&gt; &lt;!-- 左侧显示文案 --&gt; &lt;view class=&quot;uni-navbar-btn-text uni-navbar__content_view&quot; :class=&quot;{ 'uni-navbar-btn-icon-left': leftIcon }&quot; v-if=&quot;!showHome &amp;&amp; leftText.length&quot;&gt; &lt;text :style=&quot;{ color: color, fontSize: '28rpx' }&quot;&gt;{{ leftText }}&lt;/text&gt; &lt;/view&gt; &lt;!-- 左侧区域插槽（具名插槽） --&gt; &lt;slot name=&quot;left&quot; /&gt; &lt;/view&gt; &lt;!-- 标题区域 --&gt; &lt;view class=&quot;uni-navbar__header-container uni-navbar__content_view&quot;&gt; &lt;view class=&quot;uni-navbar__header-container-inner uni-navbar__content_view&quot; v-if=&quot;title.length&quot;&gt; &lt;text class=&quot;uni-nav-bar-text&quot; :style=&quot;{color: color }&quot;&gt;{{ title }}&lt;/text&gt; &lt;/view&gt; &lt;!-- 标题插槽（无名插槽） --&gt; &lt;slot /&gt; &lt;/view&gt; &lt;!-- 右侧按钮区域 --&gt; &lt;view @tap=&quot;onClickRight&quot; class=&quot;uni-navbar__header-btns uni-navbar__header-btns-right uni-navbar__content_view&quot; :style=&quot;{width: rightIconWidth}&quot;&gt; &lt;view class=&quot;uni-navbar__content_view&quot; :class=&quot;{'header-icon-with-bg': showIconBg}&quot; v-if=&quot;rightIcon&quot;&gt; &lt;com-icons :color=&quot;color&quot; :name=&quot;rightIcon&quot; size=&quot;56rpx&quot; /&gt; &lt;/view&gt; &lt;!-- 优先显示图标 --&gt; &lt;view class=&quot;uni-navbar-btn-text uni-navbar__content_view&quot; v-if=&quot;rightText.length &amp;&amp; !rightIcon.length&quot;&gt; &lt;text class=&quot;uni-nav-bar-right-text&quot;&gt;{{ rightText }}&lt;/text&gt; &lt;/view&gt; &lt;!-- 右侧区域插槽（具名插槽） --&gt; &lt;slot name=&quot;right&quot; /&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 副标题（样式完全自定义） --&gt; &lt;view class=&quot;uni-navbar__sub-header&quot;&gt; &lt;slot name=&quot;sub-nav&quot;&gt;&lt;/slot&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 标题区域占位 --&gt; &lt;view class=&quot;uni-navbar__placeholder&quot; v-if=&quot;fixed &amp;&amp; holdPlace&quot;&gt; &lt;com-status-bar v-if=&quot;statusBar&quot; /&gt; &lt;view class=&quot;uni-navbar__placeholder-view&quot; :style=&quot;{'padding-top': subHeaderHeight, height: headerHeight}&quot;/&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;// 首页路径const HOME_PATH = 'pages/index/index'var CustomNavbarHeight = uni.getCustomNavbarHeight() /** * NavBar 自定义导航栏 * @description 导航栏组件，主要用于头部导航 * @tutorial https://ext.dcloud.net.cn/plugin?id=52 * @property {String} title 标题文字 * @property {String} leftText 左侧按钮文本 * @property {String} rightText 右侧按钮文本 * @property {String} leftIcon 左侧按钮图标（图标类型参考 [Icon 图标](http://ext.dcloud.net.cn/plugin?id=28) type 属性） * @property {String} rightIcon 右侧按钮图标（图标类型参考 [Icon 图标](http://ext.dcloud.net.cn/plugin?id=28) type 属性） * @property {String} leftIconWidth （扩展属性）左侧按钮区域宽度 用来满足设计稿要求 * @property {String} rightIconWidth （扩展属性）右侧按钮区域宽度 用来满足设计稿要求 * @property {String} color 图标和文字颜色 * @property {String} backgroundColor 导航栏背景颜色 * @property {Boolean} fixed = [true|false] 是否固定顶部 * @property {Boolean} holdPlace = [true|false] （扩展属性）固定在顶部时，是否需要占位 * @property {Boolean} opacity = 0-1 （扩展属性）头部透明度 用于头部滚动渐变 * @property {Boolean} statusBar = [true|false] 是否包含状态栏 * @property {Boolean} shadow = [true|false] 导航栏下是否有阴影 * @property {Boolean} border = [true|false] 导航栏下是否有边框线 * @event {Function} showLeftBack （扩展属性）是否显示返回按钮 * @event {Function} clickLeftBack （扩展属性）点击左侧区域是否关闭当前窗口 */export default { name: &quot;NavBar&quot;, props: { title: { type: String, default: &quot;&quot; }, leftText: { type: String, default: &quot;&quot; }, rightText: { type: String, default: &quot;&quot; }, leftIcon: { type: String, default: &quot;&quot; }, leftIconWidth: { type: String, default: &quot;132rpx&quot; }, rightIcon: { type: String, default: &quot;&quot; }, rightIconWidth: { type: String, default: '132rpx' }, fixed: { type: [Boolean, String], default: false }, holdPlace: { type: Boolean, default: true }, color: { type: String, default: &quot;#000000&quot; }, opacity: { type: [String,Number], default: &quot;1&quot; }, backgroundColor: { type: String, default: &quot;#FFFFFF&quot; }, statusBar: { type: [Boolean, String], default: false }, shadow: { type: [String, Boolean], default: false }, border: { type: [String, Boolean], default: true }, clickLeftBack: { // 点击返回按钮区域是否返回上一页/路由 type: [String, Boolean], default: true }, showLeftBack: { type: [Boolean, String], default: true } }, data() { return { showIconBg: false, // 是否显示按钮的背景色 showHome: false, // 是否显示回到首页按钮 showNavBar: true, headerHeight: CustomNavbarHeight + 'px', // 头部高度，默认是40 subHeaderHeight: '' // 子头部高度 } }, watch: { color() { this.handleColorChange() } }, created() { this.handleColorChange() }, mounted() { if(uni.report &amp;&amp; this.title !== '') { uni.report('title', this.title) } this.updateHeight() // #ifdef MP-WEIXIN this.judgeHome() // #endif }, updated() { this.updateHeight() }, methods: { updateHeight() { this.getSubHeaderHeight() this.getHeight() }, handleColorChange() { let color = this.color &amp;&amp; this.color.toLocaleLowerCase() // 只有背景色透明才设置按钮的背景颜色 let bgTransparent = this.backgroundColor == 'transparent' || this.backgroundColor == 'inherit' // 设置状态栏字体颜色 if (color &amp;&amp; (color === '#ffffff' || color === '#fff')) { uni.setNavigationBarColor({ frontColor: '#ffffff', backgroundColor: 'transparent' }) if (bgTransparent) this.showIconBg = true } else { uni.setNavigationBarColor({ frontColor: '#000000', backgroundColor: 'transparent' }) this.showIconBg = false } }, /** * 获取节点offset值 （而非小程序提供的相对可视窗口的offset值） * @param {string} selector 节点 与 select()方法一致 * @param {string} parent 节点相对滚动节点，非必传，不传以 viewport为默认值 * @param {string} context 查询上下文（页面/组件实例），含有自定义组件的页面，或者自定义组件中调用，必传 */ getOffset(selector, parent, context) { let query = context ? context.createSelectorQuery() : uni.createSelectorQuery(); let parentQuery = parent ? query.select(parent) : query.selectViewport() query.select(selector).boundingClientRect() parentQuery.scrollOffset() return new Promise((resolve, reject) =&gt; { query.exec(([selectRect, parentRect]) =&gt; { if (selectRect) { resolve({ top: selectRect.top + parentRect.scrollTop, left: selectRect.left + parentRect.scrollLeft, height: selectRect.height, width: selectRect.width, bottom: selectRect.bottom }) } else { console.warn(`[mp::getOffset]: 获取目标元素${selector}的offset信息失败`) resolve({ top: 0, left: 0, height: 0, width: 0 }) } }) }) }, async getSubHeaderHeight() { let subHeaderOffset = await this.getOffset('.uni-navbar__sub-header', null, this) this.subHeaderHeight = subHeaderOffset.height + 'px' }, async getHeight() { let navOffset = await this.getOffset('.uni-navbar__content', null, this) return navOffset }, // #ifdef MP-WEIXIN /** * 判断是否需要显示home按钮（只有小程序需要） **/ judgeHome() { // 页面栈栈顶，且路径为非首页，则显示home按钮 let pages = getCurrentPages() if ((pages.length &lt;= 1) &amp;&amp; HOME_PATH !== pages[0].route) { this.showHome = true } }, goHome() { uni.reLaunch({ url: '/'+HOME_PATH, }) }, // #endif onClickLeft() { if (this.clickLeftBack) { uni.navigateBack() } else { this.$emit(&quot;clickLeft&quot;); } }, onClickRight() { this.$emit(&quot;clickRight&quot;); } }};&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt; $nav-height: 44px; .uni-nav-bar-text { font-size: $uni-font-size-lg; } .uni-nav-bar-right-text { font-size: $uni-font-size-base; } .uni-navbar { position: relative; width: 100%; font-family: PingFangSC-Medium, PingFang SC; box-sizing: border-box; } .uni-navbar__content { position: relative; width: 100%; background-color: $uni-bg-color; } .uni-navbar__content_view { display: flex; align-items: center; flex-direction: row; } .uni-navbar__header { display: flex; flex-direction: row; width: 100%; height: $nav-height; line-height: $nav-height; font-size: 32rpx; } .header-icon-with-bg { display: flex; justify-content: center; align-items: center; align-content: center; background: rgba($color: #000000, $alpha: 0.2); border-radius: 100%; height: 52rpx; width: 52rpx; } .uni-navbar__header-btns { display: flex; flex-wrap: nowrap; padding: 0 12px; justify-content: center; align-items: center; box-sizing: border-box; } .uni-navbar__header-btns-left { display: flex; box-sizing: border-box; justify-content: flex-start; } .uni-navbar__header-btns-right { display: flex; box-sizing: border-box; justify-content: flex-end; margin-right: 10rpx; } .uni-navbar__header-container { flex: 1; font-weight: 600; } .uni-navbar__header-container-inner { display: flex; flex: 1; align-items: center; justify-content: center; font-size: $uni-font-size-base; } .uni-navbar__placeholder-view { height: $nav-height; box-sizing: content-box; } .uni-navbar--fixed { position: fixed; z-index: 998; } .uni-navbar--shadow { box-shadow: 0 1px 6px #ccc; } .uni-navbar--border { border-bottom-width: 1rpx; border-bottom-style: solid; border-bottom-color: $uni-border-color; }&lt;/style&gt;","link":"/2020/11/20/uni-app/com-nav-bar/"},{"title":"uni-app 小程序状态栏组件","text":"小程序状态栏高度通过wx.getSystemInfoSync().statusBarHeight获取是最准确的。单位是px。wx.getMenuButtonBoundingClientRect()方法获取的top属性时不准确的，不能作为参考。 12345678910111213141516171819202122232425&lt;template&gt; &lt;view :style=&quot;{ height: statusBarHeight }&quot; class=&quot;uni-status-bar&quot;&gt; &lt;slot /&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;const statusBarHeight = uni.getStatusBarHeight()export default { name: 'status-bar', data() { return { statusBarHeight: statusBarHeight + 'px' } }}&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt; .uni-status-bar { width: 750rpx; height: 20px; }&lt;/style&gt;","link":"/2020/11/20/uni-app/com-status-bar/"},{"title":"uni-app H5模式下treeShaking的坑","text":"uni-apph5打包模式，使用treeShaking时，该配置只在生产模式下有效，即使部署到测试和预生产都没有问题，发布到生产之前一定要先本地打包生产模式确保无异常。 我们的项目发布到生产之后运行h5出现以下报错： 经过一番全局搜索，看到了一个插件（目录：@dcloudio/vue-cli-plugin-uni-optimize/packages/babel-plugin-uni-api/index.js）： 1234567891011121314151617181920process.UNI_APIS = new Set()module.exports = function ({ types: t}) { return { visitor: { MemberExpression (path, state) { if ( t.isIdentifier(path.node.object) &amp;&amp; ( path.node.object.name === 'uni' || path.node.object.name === 'wx' ) ) { process.UNI_APIS.add(path.node.property.name || path.node.property.value) } } } }} 该插件在获取了AST语法树之后，将遇到uni.xxx语法的对象属性引用对应的api名称添加到process.UNI_APIS中。 然而，通过调试发现代码并没有运行到此处，此路不通。 后来终于发现了一个关键线索。 读取optimization.treeShaking开关并标记 @dcloudio/vue-cli-plugin-uni/lib/env.js文件中读取到optimization.treeShaking配置为true时，就会执行以下代码： 1process.env.UNI_OPT_TREESHAKINGNG = true vue-cli-optimize插件 vue-cli-plugin-uni-optimize插件（@dcloudio/vue-cli-plugin-uni-optimize/index.js）针对uni-api做了以下事情： 将process.UNI_APIS写入@dcloudio\\vue-cli-plugin-uni-optimize.tmp\\api.js路径下的文件 将uni api的模块引用路径替换成@dcloudio\\vue-cli-plugin-uni-optimize.tmp\\api.js路径下的文件 但是我们从前文可知，唯一一处更新process.UNI_APIS的代码并未执行（猜测是uni-app代码的bug），导致uni-api update了个寂寞: 以上关键代码并未更新任何api，只是引入了一些默认的核心api（@dcloudio/vue-cli-plugin-uni-optimize/packages/webpack-optimize-plugin/api.js）: 以上代码标记部分，manifest[name][2]的值为true，即为核心api时才会被默认引入。 由于不知道什么原因没有使用babel-plugin-uni-api，而且，考虑到该插件的tree-shaking比较粗暴，增加了业务代码的开发复杂度。 而我负责的项目，业务中存在对uni的直接使用扩展运算符来实现uni-api和其它自定义api的整合： 1234sdk = { ...uni, someCustomApi: function(){...}} 即使babel-plugin-uni-api插件正常工作，根据该插件的shaking原理，我们需要将扩展运算符改为按需赋值的结构： 12345sdk = { api1: uni.api1, api2: uni.api2, someCustomApi: function(){...}} 每增加一个新的uni-api都要去修改sdk文件，这是开发不希望发生的事情。因此考虑简单粗暴从manifest.json文件入手，让每一个api都成为核心api。在compiler的beforeCompile钩子回调中修改manifest文件的标记： 12345678910111213const manifest = require('@dcloudio/uni-h5/manifest.json')Object.keys(manifest).forEach(name =&gt; { if (manifest[name].length &lt; 3) { manifest[name].push(true) }})const newManifest = JSON.stringify(manifest, null, 2);try { fs.writeFileSync(path.resolve(process.cwd(), 'node_modules', '@dcloudio/uni-h5/manifest.json'), newManifest) console.log('@dcloudio/uni-h5/manifest.json 替换成功...')} catch (err) { console.log('@dcloudio/uni-h5/manifest.json 替换失败...')} writeFileSync将json写回文件时，需要转化为字符串，为了让字符串能够换行，保持json格式，需要传入JSON.stringify的第三个参数值为2，表示保留换行和空格，以及每次缩进使用2个空格。 结果将“未开启tree-shaking”，“开启tree-shaking打包异常”，“开启tree-shaking并修复api打包异常”3个版本打包结果对比： 可以看到，uni-app的tree-shaking效果一般，修复tree-shaking的打包结果依旧比开启前少了0.1M。 uni-app 2.2 大幅优化H5端性能体验，只开发H5，也要用uni-app这篇文章提到，manifest内部的的tree-shaking其实主要做了2件事，内置组件的treeShaking和api的treeShaking，而且，文中数据显示，shaking效果拔群。但是本人尝试的结果发现效果实在一般。","link":"/2021/05/10/uni-app/h5-tree-shaking/"},{"title":"defineProperty","text":"定义了如下一个对象： 123456789101112let arr = { a: []}Object.defineProperty(arr, 'a', { get() { console.log('get') return [] }, set(val) { console.log('set') }}) 当执行arr.a = [1, 2]时输出 1set 当执行arr.a.push(1)或者arr.a[0] = 1时输出 1get 这说明，Array的元素的增减不会触发setter。 那，为什么在 Vue中，arr.a[0] = 1不会触发视图更新，但是arr.a.push(1)却可以呢。 Vue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括： push, pop, shift, unshift, splice, sort, reverse 截取核心的代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/* observer/array.js */import { def } from '../util/index'const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)[ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) { // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) { // 执行默认行为 original: Array.prototype[method] const result = original.apply(this, args) // ob: Observer实例 const ob = this.__ob__ // 获取数组中新增的元素，并为其添加watcher let inserted switch (method) { case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break } if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result })})// ------------------------------------- ///* util/lang.js *//** * Define a property. */export function def (obj: Object, key: string, val: any, enumerable?: boolean) { Object.defineProperty(obj, key, { value: val, enumerable: !!enumerable, writable: true, configurable: true })}// ------------------------------------- ///* observer/index.js */import { arrayMethods } from './array'function protoAugment (target, src: Object, keys: any) { target.__proto__ = src}function copyAugment (target: Object, src: Object, keys: Array&lt;string&gt;) { for (let i = 0, l = keys.length; i &lt; l; i++) { const key = keys[i] def(target, key, src[key]) }}// ...export class Observer { value: any; dep: Dep; vmCount: number; // number of vms that has this object as root $data constructor (value: any) { this.value = value this.dep = new Dep() this.vmCount = 0 def(value, '__ob__', this) if (Array.isArray(value)) { const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) this.observeArray(value) } else { this.walk(value) } } // ... /** * Observe a list of Array items. */ observeArray (items: Array&lt;any&gt;) { for (let i = 0, l = items.length; i &lt; l; i++) { observe(items[i]) } }} 输出挂载在Vue实例上的数组和未挂载在Vue实例上的数组进行比较： 1234567891011121314151617181920&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;new Vue({ data: { arr: [1, 2] }, created() { console.log('arr on vue:', this.arr) console.log('arr free:', [1, 2]) }})&lt;/script&gt;&lt;/html&gt; 输出对比： 可以看出来，挂载在vue实例上的数组，原型是arrayMethods，arrayMethods继承于Array。 上面输出的结果说明了什么？只有调用了数组上的’push’,’pop’,’shift’,’unshift’,’splice’,’sort’,’reverse’方法，才能触发watcher更新DOM。 可运行下面的代码以做验证： 12345678910111213141516171819202122232425262728293031&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-for=&quot;number in arr&quot;&gt; {{number}} &lt;/div&gt; &lt;button @click=&quot;push&quot;&gt;push&lt;/button&gt; &lt;button @click=&quot;rawPush&quot;&gt;rawPush&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt;new Vue({ el: '#app', data: { arr: [1, 2] }, methods: { push() { this.arr.push('3') }, rawPush() { Array.prototype.push.apply(this.arr, [4]) } }})&lt;/script&gt;&lt;/html&gt; 上面的代码中，push方法执行后视图立即更新。rawPush方法执行后视图没有更新，但是内容有push成功。下次执行push方法才会把rawPush进去的值渲染出来。 为什么有时候直接对数组的某个元素赋值却发现有更新呢？ 原因是存在搭便车的情况。请看如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;changeArr&quot;&gt;修改arr&lt;/button&gt; &lt;button @click=&quot;changeProp&quot;&gt;修改prop&lt;/button&gt; &lt;button @click=&quot;changeBoth&quot;&gt;一起修改&lt;/button&gt; &lt;div&gt;arr:&lt;/div&gt; &lt;div v-for=&quot;(item, $index) in arr&quot; :key=&quot;$index&quot;&gt;{{item}}&lt;/div&gt; &lt;div&gt;&lt;br&gt;prop:&lt;/div&gt; &lt;div&gt;{{JSON.stringify(prop)}}&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { arr: [1, 2], prop: { a: { b: { c: '' } } } } }, methods: { changeProp() { this.prop.a.b.c = 'hello' }, changeArr() { this.arr[0] = 111 }, changeBoth() { this.changeProp() this.changeArr() } }}&lt;/script&gt; 对数组的某个元素直接修改，视图不会先更新，除非在修改之后其它因素触发了视图更新。 假如，prop属性没有渲染在视图中，那么，点击任何一个按钮都不会刷新视图。","link":"/2019/11/03/vue/define-property/"},{"title":"vue 的mount 过程","text":"前段时间学习了vue的源码，理清了vue的mount流程，在此做下总结。 mount过程分为2个大阶段，生成vnode，和渲染dom 生成vnodemount方法其实调用了render函数，该函数返回的就是vnode 渲染 dom这个过程主要调用了update方法。每一个vnode的渲染都会调用一次update方法。 针对组件，render返回的对应vnode只是一个占位vnode。在update的时候占位vnode会根据组件配置生成所有内容的dom。 渲染过程其实是一个深度遍历的过程。即，最先生成子dom，逐个层级向上插入，直到插入根结点的dom中。","link":"/2020/04/02/vue/mount-flow/"},{"title":"常见的vue 报错信息","text":"模板渲染初始化问题1Proxy.render Cannot read property '0' of undefined 上面这个报错是指在构建DOM的时候，有个变量是undefined，但是这个变量被当成Array类型并访问了下标值。 这种情况通常出现在数据初始化的时候，某些属性不存在，但是访问了这个不存在的属性的子属性 计算属性绑定v-model1Computed property &quot;&quot; was assigned to but it has no setter. 通常这个报错的原因是，用一个计算属性绑定到v-model上面。 1234567891011121314// template部分&lt;el-rate v-model=&quot;rate&quot; disabled&gt;&lt;/el-rate&gt;// js部分computed: { rate() { if (this.detail) { return parseFloat(this.detail.starRating) || 0 } else { return 0 } } } 解决办法 尽量避免计算属性用在v-model上，因为计算属性一般是通过现有的值计算出来的。如果可以通过其它方式修改计算属性的话，数据状态会比较混乱。 计算属性默认是只有getter的，就是说只能取值，不能设值。computed支持手动添加set函数。具体参考vue 计算属性","link":"/2020/07/09/vue/vue-error/"},{"title":"vue runtime 和 esm","text":"一. esm是vue 的“运行时”和“编译器”的集合运行时运行时是用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。 编译器用来将模板字符串编译成为 JavaScript 渲染函数的代码。 在客户端编译模板包含以下情况： el属性指定模版挂载的DOM，和该DOM包含的html，也就是说，既没有指定template，又没有render函数 用template属性指定模板渲染的字符串 如何选择vue的package.json文件中的module属性指定了模块的入口文件为vue.runtime.esm.js，为什么呢，因为这个只包含了运行时，不包含编译器。相比全部包含的vue.esm.js文件而言，vue.runtime.esm.js体积小了将近三分之一，初始化运行速度相对来说会高一些。 我发现，在开发单页应用的时候，绝大多数情况下可以避免出现使用编译器的情况，所以，我只说下我遇到的情况。 通常，我们的单页应用的入口html，入口文件和顶级组件分别是index.html, main.js和App.js。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- main.js --&gt;import Vue from 'vue'import App from './App'Vue.config.productionTip = falsenew Vue({ el: '#app', template: '&lt;App/&gt;', components: {App}})&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div&gt; HelloWorld &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'App'}&lt;/script&gt; 就像上面这种情况，初始化根实例的时候，用template指定了挂载元素，这就意味着，一定要用编译器。如果你的webpack.config.js里面没有设置vue的alias，并且，在main.js文件中，直接使用import Vue from ‘vue’，你会发现，浏览器会报错: 1[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build. 但是，如果你把 1import Vue from 'vue' 改成 1import Vue from 'vue/dist/vue.esm.js' 就会运行正常。不知道有多少项目都只是因为这个根实例导致不得不引入vue.esm.js。 那么，针对这个情况怎么解决呢？想必很多人都知道答案了。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- main.js --&gt;import Vue from 'vue'import App from './App'Vue.config.productionTip = falsenew Vue({ el: '#app', render(h) { return h(App) }})&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div&gt; HelloWorld &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'App'}&lt;/script&gt; 其实只改了一行代码，就是把main.js中的template替换成render函数。之前发现有的项目用render有的直接template，现在才知道是这么回事。 二. esm和common什么关系，为什么除了runtime.esm和esm之外，还有vue.common.js和vue.js呢？1. esm全称是ESModule，意思是遵循es6的import export模块化规则。2. common的意思是遵循common.js的exports模块化规则。3. 如何选择?我们知道common.js的模块化是输出一个exports对象，没法做到按需引入，一旦引入，就是用 require引入整个exports对象。但是ES6的import 可以选择引入哪些属性。 前者是运行时引入，后者是编译时引入（NodeJS打包）。由于编译时即可知道哪些是没有用到的，这样就可以达到tree shaking的目的（通过webpack配合达到）。 esm.js文件里面是符合ES6模块规则的es5的语法，是经过babel编译过的。为什么要是es5的语法呢？一般情况下业务代码在使用babel-loader的时候会exclude掉node_module目录，这是因为，node_module目录里面有大量的源代码，处理起来很浪费时间，所以干脆模块开发者帮你编译好，别人直接用你编译好的，而且能tree shaking的代码版本即可。","link":"/2020/08/01/vue/vue-runtime-compile/"},{"title":"凹槽样式小结","text":"border-radius由于border-radius的最大半径是50%，无法直接实现大弧度。独立一个元素，使其尺寸是容器的1倍以上，再通过平易即可实现视觉上的凹槽效果。 123456789101112131415161718&lt;!--html--&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;curved-bg&quot;&gt;&lt;/div&gt;&lt;/div&gt;// css.container { width: 300px; height: 300px; overflow: hidden;}.curved-bg { width: 300%; height: 300%; margin-top: -250%; margin-left: -100%; border-radius: 50%; background-color: rgba(0, 0, 0, 0.3);} 以上方法只是对一个简单的背景做圆角处理。试想以下这样的场景：圆弧部分只是一个修饰，图片部分的轮播图可响应点击交互，如下图banner底部的大圆弧。 针对这样的场景，border-radius方法依旧可以用，只不过需要用到pointer-event:none实现点击穿透。该属性绝大部分浏览器目前都支持。 切图最简单的办法，就是将有弧度的部分切成一张png图盖在banner下方，由于这一个区域的高度较浅，不影响点击交互。 curved border-radius可以通过椭圆圆角实现： 123456789101112131415161718&lt;!--html--&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;curved-bg2&quot;&gt;&lt;/div&gt;&lt;/div&gt;// css.container { width: 300px; height: 300px; overflow: hidden;}.curved-bg2 { height: 100%; margin-top: -50%; background-color: rgba(0, 0, 0, 0.3); /* Curved corners */ border-bottom-left-radius: 50% 10%; border-bottom-right-radius: 50% 10%;} 利用了border-radius的裁剪形状。具体参考border-top-left-radius 以上2种方法渲染结果对比： 前者的效果两端较为平缓，而curved border-radius的两端比较陡峭，接近于垂直。视觉上curved border-radius效果一般。 radio-gradient用一个mask元素盖在banner上层，使用径向渐变，结合pointer-event:none实现点击穿透。 123456789101112131415.mask { position: absolute; width: 500px; height: 500px; left: 0; top: 0; background: #fff; background: radial-gradient(ellipse closest-side at center, transparent 919rpx, #fff 920rpx); background-size: 100px 500px; background-position: -891rpx -456rpx; background-repeat: no-repeat; pointer-events: none;} ellipse表示形状为椭圆。 椭圆怎么定义边界呢？ farthest-corner、closest-side 、closest-corner 、farthest-side。 closest-side表示background-size指定的背景画布的4条边，水平和垂直方向各自距离椭圆圆心最近的边和这个椭圆边界相切。farthest-side同理。 closest-corner首先选择最近的角，作为椭圆和画布边缘的相交点1，然后再在该角的2个邻边分别做相交点1的对称角，称为相交点2和相交点3。有了椭圆圆心，i以及3个交点，可以唯一确定一个椭圆的形状。这一点在很多网站上都没有讲清楚，经过实践总结出来的规律。 除了farthest/closest、side/corner组成的关键字之外。可以具体定义水平和垂直的半径。 center表示椭圆的圆心在background-size界定的范围中的相对位置。 在给颜色标注位置时，如果是具体数值而不是百分比，则数值是以椭圆水平方向的半径为最大值，MDN有个专业词Virtual gradient ray，翻译为虚拟渐变射线： 12&lt;p&gt;&lt;strong&gt;closest-side：&lt;/strong&gt;&lt;/p&gt;&lt;div id=&quot;grad1&quot;&gt;&lt;/div&gt; 123456#grad1 { height: 150px; width: 300px; background-color: red; /* 浏览器不支持的时候显示 */ background-image: radial-gradient(closest-side at 50% 50%, red 70px, yellow 80px, black 150px); } 水波纹效果在寻找方案的时候看到了一个有意思的水波纹。 实现原理就是多个方形容器旋转。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;div class=&quot;wave&quot;&gt; 水波纹效果 &lt;div class=&quot;wave1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;wave2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;wave3&quot;&gt;&lt;/div&gt;&lt;/div&gt;.wave{ position: relative; border: 1px solid silver; width: 100px; height: 100px; border-radius: 50%; line-height: 50px; margin: 0 auto; font-size: 14px; text-align: center; overflow: hidden; animation: water-wave linear infinite;}.wave1{ position: absolute; top: 40%; left: -25%; background: #33cfff; opacity: .7; width: 200%; height: 200%; border-radius: 40%; animation: inherit; animation-duration: 5s;}.wave2{ position: absolute; top: 40%; left: -35%; background: #0eaffe; opacity: .7; width: 200%; height: 200%; border-radius: 35%; animation: inherit; animation-duration: 7s;}.wave3{ position: absolute; top: 50%; left: -35%; background: #0f7ea4; opacity: .3; width: 200%; height: 200%; border-radius: 33%; animation: inherit; animation-duration: 11s;}@keyframes water-wave{ 0% {transform: rotate(0deg);} 100% {transform: rotate(360deg);}}","link":"/2021/06/02/css/curved-radius/"},{"title":"webpack中的chunk和bundle","text":"chunk是webpack运行时的概念，bundle是webpack的执行结果，即生成了多少个文件。 chunk和entry一个entry对应一个chunk。chunk属于一个webpack构建过程中的概念。一个entry对应一个依赖树，这个依赖树所有依赖的集合就是一个chunk。 原始条件下，每个chunk对应生成一个bundle。 如果多个entry之间存在包含关系，则可能一个bundle打包多个chunk。 1234entry: { index: './src/index.js', add: './src/add.js'}, index引用了add.js。最终的打包结果，index.js中包含了chunk 0，即出现了重复打包。 1234567891011121314Hash: 8471c9024ea2740e855fVersion: webpack 4.46.0Time: 3338msBuilt at: 2021-06-02 11:59:15 AM Asset Size Chunks Chunk Names add.js 987 bytes 0 [emitted] addindex.js 72.5 KiB 1, 0 [emitted] indexEntrypoint index = index.jsEntrypoint add = add.js[0] ./src/add.js 49 bytes {0} {1} [built][1] ./node_modules/lodash/lodash.js 531 KiB {1} [built][2] ./src/index.js 89 bytes {1} [built][3] (webpack)/buildin/global.js 472 bytes {1} [built][4] (webpack)/buildin/module.js 497 bytes {1} [built] sourcemap和chunksoucemap选项如果不含inline，则会针对每个bundle生成生成一个map文件。 同名js文件和map文件同属于一个chunk。 runtimechunk它的作用是将包含chunks 映射关系的 list单独从 app.js里提取出来，因为每一个 chunk 的 id 基本都是基于内容 hash 出来的。 想一下这个场景，app.js-&gt;about.js。about因为某种原因（如按需加载）被打包为单独的bundle。每次about变化，就意味着about的hash变化，app.js中存在对about.js的引用路径，进而导致app.js也变化。 单独抽离 runtimeChunk 之后，每次打包都会生成一个runtimeChunk.xxx.js，其实这个文件非常的小，gzip 之后一般只有几 kb，但这个文件又经常会改变，我们每次都需要重新请求它，它的 http 耗时远大于它的执行时间了，所以建议不要将它单独拆包，而是将它内联到我们的 index.html 之中(index.html 本来每次打包都会变)。可以使用 inline-manifest-webpack-plugin或者 assets-webpack-plugin等来实现内联的效果。 runtimeChunk值为true或者’multiple’时会为每个entry生成1个文件。值为false时，所有的entry bundle共用一个chunk。 生成的runtime chunk需要插入index.html。 参考：webpack中的runtimeChunk spiltChunks该选项可以配置chunk之间的公共模块独立生成chunk，或者满足某些正则的模块独立出一个chunk。因此，该选项影响最终的bundle和chunk数目。 123456789101112131415161718192021222324252627282930313233const path = require('path')module.exports = { mode: 'production', devtool: 'none', entry: { index: './src/index.js', add: './src/add.js' }, output: { filename: '[name].[contenthash:8].js', path: path.resolve(__dirname, 'dist') }, optimization: { runtimeChunk: true, minimize: false, splitChunks: { cacheGroups: { common: { chunks: 'initial', minChunks: 2, minSize: 0, name: 'common' }, vendor: { test: /node_modules/, chunks: 'initial', name: 'vendor', enforce: true } } } }} 以上配置生成结果如下： 1234567891011121314 Asset Size Chunks Chunk Names add.559b3164.js 81 bytes 1 [emitted] [immutable] add common.a3657c09.js 326 bytes 0 [emitted] [immutable] common index.56507b59.js 739 bytes 2 [emitted] [immutable] index runtime~add.a5423113.js 6.11 KiB 3 [emitted] [immutable] runtime~addruntime~index.626b59fe.js 6.11 KiB 4 [emitted] [immutable] runtime~index vendor.4939a6bb.js 533 KiB 5 [emitted] [immutable] [big] vendorEntrypoint index [big] = runtime~index.626b59fe.js common.a3657c09.js vendor.4939a6bb.js index.56507b59.jsEntrypoint add = runtime~add.a5423113.js common.a3657c09.js add.559b3164.js[0] ./node_modules/lodash/lodash.js 531 KiB {5} [built][1] ./src/add.js 49 bytes {0} [built][2] ./src/index.js 147 bytes {2} [built][3] (webpack)/buildin/global.js 472 bytes {5} [built][4] (webpack)/buildin/module.js 497 bytes {5} [built] add.559b3164.js和index.56507b59.js是由于entry生成的。 common.a3657c09.js和vendor.4939a6bb.js是由于splitChunks生成的。 runtimeadd.a5423113.js和runtimeindex.626b59fe.js是由于runtimeChunk: true生成的。","link":"/2021/06/02/webpack/chunk-bundle/"},{"title":"纯css实现优惠券样式","text":"核心知识点： radial-gradient实现优惠券卡片左右2边的缺角 background可以叠加多个效果 12345&lt;div class=&quot;ticket&quot;&gt; · 海外留学项目最高立减&lt;span&gt;5000&lt;/span&gt;元现金 &lt;br&gt; · 语言培训项目最高立减&lt;span&gt;2000&lt;/span&gt;元现金 &lt;br&gt; · 国际部项目最高三年&lt;span&gt;全额奖学金&lt;/span&gt;现场发放&lt;/div&gt; 1234567891011121314151617.ticket{ width: 3.45rem;//内容层的宽度 height: 1.14rem;//内容层的高度 margin: 0 auto; box-sizing: border-box; padding: 0.25rem 0.3rem;font-size: 0.15rem; line-height: 1.5; color: #fff; background: radial-gradient(circle at 0 0.57rem, transparent 0.15rem, #ffbcbe 0.06rem) top left, linear-gradient(0.25turn, #ffbcbe, #000), radial-gradient(circle at 0.17rem 0.57rem, transparent 0.15rem, #000 0.16rem) bottom right; background-size: 0.17rem 1.14rem, 2.95rem 1.14rem, 0.17rem 1.14rem; background-size: 0.17rem 1.14rem, 2.95rem 1.14rem, 0.17rem 1.14rem; background-repeat: no-repeat; background-position: 0.1rem 0px,0.26rem 0px,3.2rem 0px;}.ticket span{ color: #eb6877; text-decoration: underline;}","link":"/2020/05/03/css/css-coupon/"},{"title":"百度地图自定义标记","text":"最近有个业务要用到百度地图以及自定义自定义图标功能。具体浏览地址：锦江酒店-分销通需要实现的效果如下： 需要满足的交互： 左侧列表滚动时，右侧地图中心位置的标记变为左侧鼠标所在的商品上 鼠标放置在地图标记上时，显示这个标记对应的酒店名称，点击这个标记跳转到酒店详情页 这个需求的核心任务是： 地图SDK选择 实现地图的自定义标记 自定义标记的状态变化 自定义标记的点击事件监听 地图SDK选择可以选择的地图有： 腾讯 高德 百度 谷歌 我们的酒店有海外数据，由于目前（2018-11）腾讯和高德地图均未很完美的支持海外位置服务。剩下只有百度和谷歌。谷歌地图经使用发现有一些外部资源依赖被防火墙阻挡。因此最终选择了百度地图。 异步加载地图123456789101112131415161718192021222324252627282930313233343536373839404142class BaiduMap { constructor(eleId, clickCallback, coordinate) { this.mapConfig = {} this.mapContainer = eleId this.map = null this.markers = null this.hotelList = '' this.hotel = '' this.clickCallback = clickCallback this.coordinate = coordinate if (!window.BMap) { BMapSource = this.loadMap() BMapSource.then(this.initMap) } } // 1.加载地图 loadMap() { const AK = 'ySDvqVVO3wnmQS49H355c5dhl6ewk469' const BMap_URL = 'https://api.map.baidu.com/api?v=2.0&amp;amp;ak=' + AK + '&amp;s=1&amp;callback=BMapCallback' return new Promise((resolve, reject) =&gt; { // 插入script脚本 let scriptNode = document.createElement('script') scriptNode.setAttribute('type', 'text/javascript') scriptNode.setAttribute('src', BMap_URL) document.body.appendChild(scriptNode) // 百度地图异步加载回调处理 window.BMapCallback = function () { resolve(window.BMap) } }) } // 2. 初始化地图 initMap(BMap) { // ... }} 实现地图的自定义标记使用Marker类实现自定义标记。 label.addEventListener监听mouseout,mouseover事件，改变mark样式，实现标记状态变化。 Icon类添加标记图标 Label类添加文本标记 addOverlay方法将marker添加到地图上 panTo方法将某个坐标移动到地图中心位置 label.addEventListener监听click事件，实现点击跳转交互 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 3. 批量添加标记setBatchMarker() { // 为每个酒店添加一个标记 this.markers = this.hotelList.map((hotel, index) =&gt; { let new_point = new BMap.Point(hotel.longitude, hotel.latitude) let marker = new BMap.Marker(new_point) // 设置标注图标 let icon = new BMap.Icon(defaultIcon, new BMap.Size(30, 30)) marker.setIcon(icon) // 创建marker默认的标记 let content = `&lt;div&gt;&lt;span class=&quot;markerIndex&quot;&gt;${index + 1}&lt;/span&gt;&lt;span class=&quot;markerLabel&quot;&gt;${hotel.translatedName || hotel.hotelName}&lt;/span&gt;&lt;/div&gt;` let label = new BMap.Label(content, { position: new_point }) label.setStyle({ padding: 0, width: '30px', height: '30px', lineHeight: '30px', backgroundColor: 'transparent', border: 'none', color: '#fff', textAlign: 'center', overflow: 'hidden' }) marker.setLabel(label) this.map.addOverlay(marker) // 将标注添加到地图中 // 设置marker的鼠标事件（鼠标进入和离开的样式差异） // 鼠标经过时 label.addEventListener('mouseover', function () { // 修改样式 }) // 鼠标离开时 label.addEventListener('mouseout', function (e) { // 修改样式 }) // 点击 label.addEventListener('click', function (e) { // 跳转 }) return marker }) // 以列表的第一个为地图的中心点 let new_point = new BMap.Point( this.hotelList[0].longitude, this.hotelList[0].latitude ) // 将地图的中心点更改为给定的点，跳转到指定中心点进行渲染。如果该点在当前的地图视图中已经可见，则会以平滑动画的方式移动到中心点位置。 this.map.panTo(new_point)}","link":"/2018/11/05/blogs/baidu-map-mark/"},{"title":"判断浏览器是否是隐私模式","text":"很旧的版本较旧的版本，无痕模式禁用了FileSystem API。 123456789var fs = window.RequestFileSystem || window.webkitRequestFileSystem;if (!fs) { console.log(&quot;check failed?&quot;);} else { fs(window.TEMPORARY, 100, console.log.bind(console, &quot;not in incognito mode&quot;), console.log.bind(console, &quot;incognito mode&quot;));} 但是据说现在不能用了。 新一点的无痕模式下，TEMPORARY 存储配额较低。参考文章 123456789101112if ('storage' in navigator &amp;&amp; 'estimate' in navigator.storage) { const {usage, quota} = await navigator.storage.estimate(); console.log(`Using ${usage} out of ${quota} bytes.`); if(quota &lt; 120000000){ console.log('Incognito') } else { console.log('Not Incognito') } } else { console.log('Can not detect')} 但是个人使用chrome实践之后发现这个方法其实也不行，隐私模式下输出结果为： 1Using 0 out of 536504813 bytes. 现在的无痕模式看到stackoverflow的一个回答解释说，chrome76+的版本都不允许任何方式检测无痕模式。 看看现在chrome对无痕模式对解释： 在无痕模式下，您的浏览记录、Cookie、网站数据以及您在表单中输入的信息都不会保存到您的设备中。也就是说，您的活动不会显示在 Chrome 浏览器的历史记录中，因此与您共用设备的人不会看到您的活动。网站会将您视为新用户；只要您不登录，网站就无法确定您的身份。 localstorage和sessionStorage还是可以用的，只不过cookie不会保存。等下，cookie不会保存是什么概念，我们再看看： 每次您关闭所有无痕式窗口时，Chrome 都会舍弃与此浏览会话相关的所有网站数据和 Cookie。 也就是说，cookie用是可以用，但是窗口关闭的话不会保存。如果我们cookie的有效期不是session类型的，会受到影响。本来你的cookie设定7天后过期，结果今天用完关闭窗口cookie就没了。这样做也正是无痕模式的初衷，而且不影响使用。 总结现在的浏览器已经没有必要判断无痕模式了。目前的无痕模式的重点在于使用后不留下记录，不影响使用过程。","link":"/2019/03/07/blogs/incognito-mode/"},{"title":"说一说自己设计的运营后台权限","text":"权限设计我们的运营后后台的用户由多个角色组成。不同角色的使用权限区别在于： 可见的菜单不同 同一个菜单页面内可见的操作按钮不同，如是否存在编辑按钮 页面内的操作按钮可能对应着其它不在菜单内显示的路由，如编辑页面 根据以上分析，我们可以提炼出3个关键词： 菜单 路由 权限 3者之间的关系我们再捋一捋。 从顶级菜单开始，每个菜单是树状结构，每个叶子节点对应一个路由，这个路由是由1个或多个权限决定的（如查看或编辑权限任意一个存在就决定这个路由的存在）。 除了每个菜单的叶子节点对应一个路由之外，有些路由是隐藏在操作中的，和某些操作权限相关。 有些权限仅控制页面内操作，和任何路由无关。 根据以上分析，可以构思出这3个关键词的结构： 根据上图可知，权限可以有2种行为： 控制路由 控制界面 服务端维护一份菜单，菜单的字段如下： 12345{ menu_code: '', // 唯一标识 menu_name: '', // 菜单名称 p_menu_code: '', // 父级菜单} 以上结构可以维护一份菜单树。 另外维护一份路由，字段如下： 12345{ route_code: '', // 唯一标识 route_path: '', // 客户端路由路径 menu_code: '', // 关联的菜单（为空表示不显示在菜单栏，通过某操作可以跳转）} 另外最重要的是权限，字段如下： 12345{ auth_code: '', // 唯一标识 auth_name: '', // 权限名称 route_codes: [], // 关联的路由列表（若为空，表示该权限只影响界面按钮）} 如果想要在配置的时候通过菜单分类显示权限，就需要通过菜单反查对应权限，因此需要反向维护关联关系，即 菜单表要关联路由 路由表关联权限 菜单表： 123456{ menu_code: '', // 唯一标识 menu_name: '', // 菜单名称 p_menu_code: '', // 父级菜单, relate_route: [] // 关联的路由} 路由表： 123456{ route_code: '', // 唯一标识 route_path: '', // 客户端路由路径 menu_code: '', // 关联的菜单 relate_auth: [] // 关联的权限列表} 实现权限配置以顶级菜单分类显示可配置的路由： 123456789101112- 用户管理 —— 用户查看 —— 用户新增/编辑- 商品管理 —— 商品查看 —— 商品添加/编辑基本信息 —— 商品价格日历修改 —— 商品上下架- 订单管理 —— 订单查看 —— 订单操作退款 —— 财务结算 通过菜单的反向的关联关系，可以分类显示所有可配置的权限。将选中的权限列表提交后，每个角色有一份自己的权限表。 C端实现1. 登录接口返回该用户所属角色对应的权限表、路由表，树结构的菜单 权限表用于界面内操作控制 路由表用于注册有权限的路由 树结构的菜单用来初始化菜单栏 2. 动态注册路由路由分为3种，默认路由、重定向路由、受权限控制路由。 12345678910111213141516171819202122232425262728293031323334353637383940// 默认路由export const defaultRootes = [ { path: '/login', // component: login components: { login: () =&gt; import(/* webpackChunkName: &quot;base&quot; */'@/views/login') } }, { path: '/loading', // component: loading component: () =&gt; import(/* webpackChunkName: &quot;base&quot; */'@/components/bodyView/components/loading') }]// 重定向路由export const redirectRoutes = [ { path: '/', // 默认重定向路由（登录后根据权限修改） redirect: '/login' }, { path: '*', // component: notFound component: () =&gt; import(/* webpackChunkName: &quot;base&quot; */'@/components/bodyView/components/404') }]// 受权限控制路由export const routes = [ { path: '/order/list', // component: orderList component: () =&gt; import(/* webpackChunkName: &quot;order&quot; */'@/views/order') }, ...] 关于重定向，有2个细节需要注意： 根路由’/‘的重定向路由是不固定的。 在登录前，’/‘的重定向路由是’/login’ 成功登录后，需要取出第一个菜单下的第一个路由作为重定向路由。 已登录用户的”/login”路由需要重定向到首页 在App.vue中注册默认路由： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546created() { this.path = this.$route.path // 注册基本路由 this.$router.addRoutes([...defaultRootes, ...redirectRoutes]) // 检查登录状态 this.checkLogin()},methods: { checkLogin() { // 通过获取用户信息判断是否已经登录 apiGetUserInfo().then((response) =&gt; { /* 已登录 */ // 1. 保存用户信息 // 2. 初始化菜单 this.menus = response.data.menus // 3. 注册路由 const routes = response.data.routes // 将根路由'/'的重定向路由改为接口返回的第一个路由： redirectRoutes[0].redirect = routes[0].path const newRouter = new Router({ mode: 'history' }) // @ATTENTION: 执行到此处时需要重写matcher以覆盖之前注册的路由，因为addRoutes无法覆盖旧的重复路由，且官方不支持deleteRoutes方法 this.$router.matcher = newRouter.matcher this.$router.addRoutes(defaultRootes.concat(filteredRoutes, redirectRoutes)) // 4. 登录后路由跳转 if (this.path.indexOf('/login') &gt;= 0) { // 登录路由跳转到首页 this.$router.replace('/') } else { let path = this.$route.fullPath // 需要有路由变化才能重新加载此前未注册的路由 this.$router.replace('/loading') this.$router.replace(path) } // 4. 保存权限列表 this.auths = response.data.auths }).catch(() =&gt; { // 未登录，跳转到登录页面 this.goLogin() }) }} 3. 登录过期处理接口拦截器监测到token失效等鉴权失败等错误时，提示并跳转到登录页： 12345678910Vue.prototype .$confirm('登录失效，请重新登录', '提示', { confirmButtonText: '确定', cancelButtonText: '取消', type: 'warning' }).then(() =&gt; { router.push('/login') }).catch(() =&gt; { router.push('/login') })","link":"/2019/03/02/blogs/role-auth-design/"},{"title":"npm学习总结","text":"dependencies如果是工具库之类的项目，发布之后，第三方使用时会安装dependencides，优先安装在第三方的目录下。 项目依赖和工具库依赖不冲突，则依赖安装到项目下，否则就会在这个工具库的目录下再安装一份。 devDependencies普通业务项目开发时，dependencies和devDependencies区别感知不大。但是如果我们开发的是一个工具库，publish之后生成的package.json中是没有devDependencies的。 peerDependencies同等依赖。这个同等的意思是，你想引用我这个库，你最好也一起安装这些依赖，要和我平级安装在你的目录下，而不是像dependencies一样有可能安装在我的库目录下面。 命令npm installnpm install的依赖安装处理逻辑如下图： 项目依赖和工具库依赖冲突项目依赖和工具库依赖不冲突，则依赖安装到项目下，否则就会在这个工具库的目录下再安装一份。 项目有如下依赖： 123456{ &quot;dependencies&quot;: { &quot;fetch&quot;: &quot;^1.1.0&quot;, &quot;biskviit&quot;: &quot;1.0.1&quot; }} fetch@^1.1.0的依赖如下： 12345{ &quot;dependencies&quot;: { &quot;biskviit&quot;: &quot;2.0.1&quot; }} 由于项目顶级依赖和fetch对biskviit的版本不一致，存在冲突，所以biskviit在项目的node_modules目录下安装一份1.0.1的版本，然后在node_modules/fetch/node_modules目录下安装2.0.1版本。 工具库之间依赖冲突假如项目的依赖如下： 123456{ &quot;dependencies&quot;: { &quot;fetch&quot;: &quot;^1.1.0&quot;, &quot;biskviit&quot;: &quot;2.0.0&quot; }} fetch@^1.1.0的依赖如下： 12345{ &quot;dependencies&quot;: { &quot;biskviit&quot;: &quot;1.0.1&quot; }} 安装fetch时，遇到了biskviit@1.0.1，会先检查项目依赖有没有biskviit。找到了，但是版本不一致，npm会选择较高的版本安装在顶级node_modules目录下，其余版本安装在各自工具库的目录下。 npm init初始化npm管理的项目，结果是一个package.json文件。 也可以通过config命令修改单个字段： 1234npm config set init.author.name &quot;Lucas&quot;npm config set init.author.email &quot;lucasXXXXXX@gmail.com&quot;npm config set init.author.url &quot;lucasXXXXX.com&quot;npm config set init.license &quot;MIT&quot; npm ls列出当前目录下npm包列表，以及之间的依赖关系。 npm config get cache获取npm包本地缓存的目录 私有npm搭建工具nexus、verdaccio 以及 cnpm npx 命令工具1npm install -g npx 假如，npm安装了webpack-cli，package.json有个script为： 123&quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack&quot;} 我们可以在命令行运行npm run dev执行webpack命令，但是无法在命令行直接执行webpack。只能这样： 1./node_modules/.bin/webpack npx的作用就是帮我们找到命令的路径并执行，其实就是个语法糖。 1npx webpack nrm 镜像管理设置镜像的命令： 1npm config set registry http://registry.npm.taobao.org 我们不免会出现要切换镜像的时候，但是镜像的地址可能忘记了。这时候需要一个镜像管理工具，nrm。 1234npm install -g nrmnrm add taobao/*或者其它名字*/ http://registry.npm.taobao.orgnrm ls // 查看镜像列表，以及当前使用的镜像nrm use taobao // 切换镜像 参考资料 没想到你是这样的npm install npm 安装机制及企业级部署私服原理","link":"/2021/05/20/tools/npm-learn/"},{"title":"uni-app 自定义条件编译","text":"package.json文件中添加如下配置： 123456789101112131415161718192021222324&quot;uni-app&quot;: { &quot;scripts&quot;: { &quot;mp-qly&quot;: { &quot;title&quot;: &quot;趣旅游小程序&quot;, &quot;BROWSER&quot;: &quot;&quot;, &quot;env&quot;: { &quot;UNI_PLATFORM&quot;: &quot;mp-weixin&quot; }, &quot;define&quot;: { &quot;QLY&quot;: true } }, &quot;h5-qly&quot;: { &quot;title&quot;: &quot;趣旅游h5&quot;, &quot;BROWSER&quot;: &quot;&quot;, &quot;env&quot;: { &quot;UNI_PLATFORM&quot;: &quot;h5&quot; }, &quot;define&quot;: { &quot;QLY&quot;: true } } }} 在npm script中带上custom参数： 12&quot;dev:wx:qly&quot;: &quot;uniapp-cli custom mp-qly&quot;,&quot;dev:h5:qly&quot;: &quot;uniapp-cli custom h5-qly&quot; 那么，这俩命令执行后 12// #ifdef QLY// #endif 这个条件编译是都会命中的。自定义条件编译适合在saas应用中针对业务做区分，同一个业务不同的平台保持一致性。 自定义条件编译有个缺点，就是不支持or判断 123// #ifdef BOOKING || QLYdosomething();// #endif 以上条件编译只会命中BOOKING。不会命中QLY。 解决办法 按照官方的办法处理。 分开处理123456// #ifdef BOOKINGdosomething();// #endif// #ifdef QLYdosomething();// #endif 如果是ifndef呢？既不是，也不是。 123// #ifndef BOOKING || QLYdosomething();// #endif 以上写法是不对的。可以通过嵌套解决： 12345// #ifndef BOOKING// #ifndef QLYdosomething();// #endif// #endif","link":"/2021/04/07/uni-app/custom-if/"},{"title":"vue-router 总结","text":"路由钩子（导航守卫）全局钩子beforeEach123router.beforeEach((to, from, next) =&gt; { // ...}) 异步回调，按照钩子挂载的顺序执行。有点类似于tapable的waterfall任务队列。所有的回调必须执行next才能进行下一步。 next可以做以下事情： 中断路由跳转 跳转到一个不同的地址 中断跳转并抛出错误 beforeResolve和 router.beforeEach 类似，在 beforeEach 和 组件内beforeRouteEnter 之后，afterEach之前调用。 afterEach123router.afterEach((to, from) =&gt; { // ...}) 路由切换后的回调。无法修改路由。 路由内钩子beforeEnter和beforeEach一样。区别是，这个钩子是挂在特定路由下的，表示只有跳转到当前路由前才执行的钩子。 1234567891011const router = new VueRouter({ routes: [ { path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; { // ... } } ]}) 组件内钩子beforeRouteEnter1234567beforeRouteEnter(to, from, next) { // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！直接获取组件实例 `this` // 但是可以在next回调获取`this` // 因为当守卫执行前，组件实例还没被创建 // next一定要调用} beforeRouteUpdate12345678beforeRouteUpdate(to, from, next) { // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` // next一定要调用 // next无需传参} beforeRouteLeave1234567beforeRouteLeave(to, from, next) { // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` // next一定要调用 // next无需传参 // next(false)可以阻止跳转} 完整的导航流程 导航被触发。 在失活的组件里调用 beforeRouteLeave 守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。confirmed 调用全局的 afterEach 钩子。 触发 DOM 更新。 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。","link":"/2018/08/20/vue/vue-router/"},{"title":"fiddler捕获https包的原理","text":"fiddler代理http协议大家都清楚原理，实际上就是正向代理。正向代理是什么呢？简单来说，就是，一方面，fiddler对浏览器客户端伪造成服务器，另一方面对真实的服务器伪造成客户端。 那么，https作为一种双向验证机制的协议，是如何让fiddler实现抓包的呢？ https其实就是比http多了个加密和解密的过程。 https的作用，其实依赖于证书的信任机制。受信任的证书机构向服务端颁发CA证书，浏览器以及系统默认保存了该机构的根证书。 fiddler其实是自己造了一个证书，如果想抓客户端的流量，就需要客户端手动信任该证书。这也是https抓包的关键。 具体步骤如下图：","link":"/2020/10/01/tools/https-through-fiddler/"},{"title":"项目静态资源CDN服务无响应情况的回源","text":"背景某日，华为云上部署的cdn服务故障导致部分区域静态资源（js和css）响应超时。这种情况是我们没有预料到的，幸亏用户不多，否则需要紧急发版将静态资源指向源服务器。 我们的项目采用uni-app框架开发，内部基于vue-cli。生产模式会使用publicPath配置将静态资源指向cdn服务器，即，代码经过webpack编译后资源引用地址就已经固定了。 任务拆解为了应对以上情况，我们需要实现一种机制，能够识别cdn异常，并切换资源为源服务器。 我们的任务分为以下： publicPath运行时全局变更 cdn资源请求异常识别方法 资源开关切换机制 方案分析与实施publicPath运行时全局变更经过分析打包后的模块代码： 123456/******/ function jsonpScriptSrc(chunkId) {/******/ return __webpack_require__.p + &quot;static/js/&quot; + ({&quot;project-qlymain-pages-404&quot;:&quot;project-qlymain-pages-404&quot;}[chunkId]||chunkId) + &quot;.&quot; + {&quot;chunk-0826ee9b&quot;:&quot;964d9183&quot;,&quot;chunk-69a5a22c&quot;:&quot;9e1c8209&quot;,&quot;project-qlymain-pages-404&quot;:&quot;330de720&quot;}[chunkId] + &quot;.js&quot;/******/ }/******/ ....此处省略一些中间代码/******/ // __webpack_public_path__/******/ __webpack_require__.p = &quot;/&quot;; 以及webpack源码： 123456789this.hooks.requireExtensions.tap(&quot;MainTemplate&quot;, (source, chunk, hash) =&gt; { const buf = []; const chunkMaps = chunk.getChunkMaps(); // ... // ... buf.push(&quot;// __webpack_public_path__&quot;); buf.push(`${this.requireFn}.p = ${JSON.stringify(publicPath)};`); return Template.asString(buf);}); 可以发现，publicPath被写入模块属性__webpack_require__.p上，我只需要修改这个属性值就可以了。 一开始我写了个插件，通过拦截compiler钩子修改这个模块属性： 12345678910111213141516function pushBuff(valName, defaultVal, source) { var buf = []; buf.push(source); buf.push(''); buf.push('// Dynamic assets path override (/build/plugins/runtime-publicpath-plugin)'); buf.push(`__webpack_require__.p = ${valName} || '${defaultVal}'`); return buf.join('\\n');}// ...if (compiler.hooks &amp;&amp; compiler.hooks.thisCompilation) { compiler.hooks.thisCompilation.tap('RuntimePublicpathPlugin', function (compilation) { compilation.mainTemplate.hooks.requireExtensions.tap('RuntimePublicpathPlugin', function (source, chunk, hash) { return pushBuff(globalVariable, defaultPublicPath, source) }) });} 但是，这个插件的目的是覆盖__webpack_require__.p的值为runtime的运行时全局变量（window[globalVariable]），但是我们的开关状态可能要存储到localstorage中（因为要实现状态缓存），而且存进去的字段名由业务代码决定，这样就导致插件和业务过渡耦合。 后来发现业务代码中可以使用webpack提供的变量webpack_public_path，webpack会在编译时将这些变量替换成__webpack_require__.p。 至此，我们找到了publicPath运行时的覆盖方法： 1__webpack_public_path__ = localstorage.getItem('__webpack_public_path__') 异步资源加载打包后按需加载的代码： 1234567891011121314// script path functionfunction jsonpScriptSrc(chunkId) { return __webpack_require__.p + &quot;&quot; + ({ &quot;project-qlymall-views-order-logisticsDetail&quot;:&quot;project-qlymall-views-order-logisticsDetail&quot;, &quot;project-qlymall-views-order-refundDetail&quot;:&quot;project-qlymall-views-order-refundDetail&quot; // ...... }[chunkId]||chunkId)+'.js'}// ......// 创建script标签/******/ var script = document.createElement('script');/******/ // ....../******/ script.src = jsonpScriptSrc(chunkId);/******/ 为了使我们的开关机制生效，需要保证jsonpScriptSrc方法在publicPath变更后执行。实施发现只要将以下语句放在入口文件最顶部执行即可。 1__webpack_public_path__ = localstorage.getItem('__webpack_public_path__') 插入index.html的cdn标签需要重写处理完异步加载的资源，我们还要处理入口index.html的资源。vue-cli内部使用了html-webpack-plugin将所有的assets插入了index.html中，包括pulicPath： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://mycdn.mycompany.com/static/index.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=https://mycdn.mycompany.com/static/js/index.bd9cfc6f.js&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 如何处理这种情况呢？有2个思路。 本着解决问题不如绕开问题的原则，考虑入口文件代码直接内联 入口文件也使用异步加载的方法 针对方案1，看起来很简单粗暴，但是会产生一个问题：index.html使用的是源站资源，而非cdn。index.js一般代码比较大，如果内联是不是本身就违背了cdn的初衷呢？所以最终我们采用了方案2。 入口文件异步加载让入口文件异步加载的方法，一开始想到的方案是，写插件，覆盖vue-cli使用html-webpack-plugin的默认行为，替代为动态插入script标签的逻辑，这段代码由于不经过babel，所以语法需要谨慎。想想这样做有点大费周章了。 后来发现可以直接覆盖掉入口文件，我们称之为main2.js，该文件关键代码： 1234/* 加载主入口文件 */import('@/main.js').catch(err =&gt; { handleError(err)}) 这样就巧妙实现了入口文件异步加载。那么问题来了，main2.js又会被html-webpack-plugin插入index.html。由于main2.js的代码量较少，我选择内联，使用HtmlWebpackInlineSourcePlugin将main.js内联到index.html中。 index.css的处理在调试HtmlWebpackInlineSourcePlugin的过程中发现，index.css并不在assets列表中。我们看看index.css的生成代码： 这段代码做了2件事： 通过检查html中有没有VUE_APP_INDEX_CSS_HASH来判断生辰的index.css文件名要不要带上hash 将@dcloudio/uni-h5/dist/index.css文件中的内容取出来再加工，用copyWebpackPlugin插件将文件粘贴到dist目录中。 鉴于该文件不大，可以选择内联或者在main2.js中动态插入link标签。我选择了后者。 既然选择了动态插入link标签，就要知道，index.[hash].css的文件名，如何在运行时知晓呢？很简单，使用definePlugin将VUE_APP_INDEX_CSS_HASH注入运行时即可。 cdn加载异常识别一开始想到的是使用window.addEventListener(‘error’)，但是尝试后发现无法捕获promise中的异常，所以改用window.addEventListener(‘unhandledrejection’)。 在回调中，需要做判断区分是否是资源加载超时。通过分析webpack模块源码可以发现它有做超时异常处理： 且超时时间可以通过output.chunkLoadTimeout配置修改，默认值是120s，觉得太长的可以考虑覆盖。对于现在的用户来说，12s都算很长了，所以我选择缩短到12s。此外，超时异常格式可以通过上图的type和message匹配。 cdn开关切换针对开关切换，一开始想到的方案是通过接口变更开关状态，但是这样存在以下问题： 简单的开关可以通过人为控制apollo字段实现，但是无法感知客户端异常。开发者需要实现一个客户端告警机制触发开关变更，实现成本较高。 开关属于全局性的，一旦切换到源服务器，将会对源服务器造成较大压力。 后来选择客户端自行切换开关的方案： 识别到cdn加载超时之后，我们业务的处理逻辑是：切换开关，将开关缓存5min，缓存的原因是，我们的业务属于APP内嵌h5，每个窗口都会重新初始化，所以需要窗口之间开关状态共享。 难点清单 找到动态资源拼接的代码，找到__webpack_require__.p，如何重写它，使得运行时可修改index.css处理 内联？还是动态插入的选择 index.css文件名有hash怎么办","link":"/2021/05/27/webpack/cdn-switch/"},{"title":"手写defineReactive","text":"defineReactive是Vue响应式的核心。我们手写一个简单的defineReactive： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546let obj = { c: 2}/*** 将获取到的变量值渲染到视图**/function showGet(key, val) { console.log(key, 'get newVal', val) let bodyEle = window.document.body bodyEle &amp;&amp; (bodyEle.innerText = bodyEle.innerText + '\\n' + key + ' get newVal' + val)}/*** 将更新后的变量值渲染到视图**/function showSet(key, newVal) { console.log(key, 'set newVal', newVal) let bodyEle = window.document.body bodyEle &amp;&amp; (bodyEle.innerText = bodyEle.innerText + '\\n' + key + ' set newVal' + newVal)}function defineReactive(obj, key) { let val = obj[key] Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function() { showGet(key, val) return val }, set: function (newVal) { val = newVal showSet(key, newVal) } })}let keys = Object.keys(obj)for (const key of keys) { defineReactive(obj, key)}obj.c = 3console.log(obj.c)","link":"/2019/11/03/vue/define-reactive/"},{"title":"通过一个细节学习节点复用","text":"背景有一个图片列表，被transition-group包裹： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt;&lt;div&gt; &lt;transition-group name=&quot;movee&quot;&gt; &lt;template v-for=&quot;(img, index) in images&quot;&gt; &lt;!-- key绑定为index --&gt; &lt;!-- &lt;img class=&quot;image-item movee-item&quot; :src=&quot;img&quot; :key=&quot;index&quot; alt=&quot;&quot;&gt; --&gt; &lt;!-- key绑定为img值 --&gt; &lt;img class=&quot;image-item movee-item&quot; :src=&quot;img&quot; :key=&quot;img&quot; alt=&quot;&quot;&gt; &lt;/template&gt; &lt;/transition-group&gt; &lt;div&gt; &lt;button @click=&quot;swapImage&quot;&gt;第一张和第二张交换顺序&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt;&lt;script&gt;export default { name: 'app', data() { return { images: [ '/static/image1.png', '/static/image2.png', '/static/image3.png' ] } }, methods: { swapImage() { let first = this.images.shift() let last = this.images.pop() this.images.unshift(last) this.images.push(first) } }}&lt;/script&gt;&lt;style&gt;.image-item { height: 200px;}.movee-item { transition: all 0.3s;}&lt;/style&gt; 当for循环绑定的key为index时，没有任何动画；当key为img值时，效果如下： 为什么key绑定为img值，过渡效果就生效了呢？带着这个问题重新学习了一下vue的节点复用。 key绑定根据官方文档的说法，独特的 key，可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用： 完整地触发组件的生命周期钩子 触发过渡 那么，vue是怎么判断节点复用的呢？ vue的节点树存在vDOM中。包含了节点的所有信息。当template中绑定的data属性发生变化，就会触发新的虚拟节点生成。新旧虚拟节点会进行对比，可以复用的节点不需要重新渲染到DOM中。 同一个层级下，相同的虚拟节点才可以复用真实DOM，复用其实就是把节点对应的整个element对象粘贴到新的虚拟节点elm属性值上。新旧节点需要同时满足以下条件才能判定为相同： key 相同（不绑定key 的情况下也相同，因为都是null） tag 相同（没有tag的情况下也相同，如组件和文本节点） 如果是输入框，输入框类型也要相同 贴出源码更加直观： 123456789101112131415161718192021222324function sameVnode (a, b) { return ( a.key === b.key &amp;&amp; ( ( a.tag === b.tag &amp;&amp; a.isComment === b.isComment &amp;&amp; isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) ) || ( isTrue(a.isAsyncPlaceholder) &amp;&amp; a.asyncFactory === b.asyncFactory &amp;&amp; isUndef(b.asyncFactory.error) ) ) )}function sameInputType (a, b) { if (a.tag !== 'input') return true let i const typeA = isDef(i = a.data) &amp;&amp; isDef(i = i.attrs) &amp;&amp; i.type const typeB = isDef(i = b.data) &amp;&amp; isDef(i = i.attrs) &amp;&amp; i.type return typeA === typeB || isTextInputType(typeA) &amp;&amp; isTextInputType(typeB)} 需要注意的是，输入框等表单项的value并没有作为判断依据。即，如果input的所有属性都一样，就会被认为可以复用，input并不会被重新渲染。这也解释了为什么会存在2个输入框交换顺序后绑定值和之前的顺序一致。 关于对容一个层级的理解，看下图就清楚了： 对于整个树状的vDOM，对比过程就是深度遍历的过程。 节点复用的图示vue是如何对比同一个层级新旧子节点的呢？它其实是2种方法的结合： 两两对比交叉验证 绑定key的情况下，保存一份旧的子节点key:index键值对 两两对比始终是比较消耗性能的，这也是为什么vue针对for循环要求我们绑定key。 以同一个层级的新旧列表为例，假设数组的顺序变更为：**[A, B, C, D, E] =&gt; [F, B, A, E, C, G]**，用图展示绑定key为value的过程。 👆4个箭头分别为oldStartIndex，oldEndIndex，newStartIndex, newEndIndex。旧A-新F，旧A-新G，旧E-新F，旧E-新G这4对对应的vNode进行比较。 👆由于绑定的key值不同，认定为不同的节点。接下来将通过key:index映射来尝试找到newStartNode。 👆newStartNode通过key也没找到，因此新建一个DOM元素，插入到oldStartNode指向的DOM节点之前 👆newStartVnode已经完成DOM创建和插入，接下来右移newStartIndex 👆新B-旧A，新B-旧E，新G-旧A，新G-旧E这4对又开始对比（这里发现有个问题，新G-旧A，新G-旧E重复对比了，这算不算一个优化点呢？vue@2.6.11）。 👆对比结果又是没匹配上。新B通过key:index映射找到了原身，旧B对应的DOM节点则移动到oldStartNode的前面。 👆新B的DOM节点已经安顿好了，新B对应的old vNode位置也对应从数组删除，为了不影响现有索引位置，只是old vNode的值设置为undefined。newStartIndex右移一位。 👆新A-旧A识别为相同的节点，由于都是startIndex，因此二者对应的DOM节点在父元素中的位置保持不变。oldStartIndex和newStartIndex右移一位 👆新E-旧E识别为相同节点。旧E（oldEndIndex）对应的DOM移动到旧C（oldStartIndex）对应的DOM节点之前👇 👇oldStartIndex和newStartIndex右移一位，oldStartIndex遇到旧B的位置为undefined，继续右移。 根据上一轮的匹配结果，oldEndIndex对应vNode置空，oldEndIndex左移，newStartIndex右移👇 👆新C-旧C识别为相同的节点，由于都是startIndex，因此二者对应的DOM节点在父元素中的位置保持不变。oldStartIndex对应的vNode置空，oldStartIndex和newStartIndex右移一位。 👆oldStartIndex和oldEndIndex相遇，newStartIndex和newEndIndex相遇。新G-旧D无法识别为相同节点。通过key:index映射也无法匹配上，说明G是新增节点。 👆针对G新建DOM节点，插入oldStartIndex对应DOM节点之前。 👆由于新G已安顿好，newStartIndex右移，但是越界，因此循环终止。 👆删除oldStartIndex和oldEndIndex之间的vNode以及DOM节点。 总结 循环条件：旧startIndex &lt;= 旧endIndex 且 新startIndex &lt;= 新endIndex 若旧startIndex 与 新startIndex 匹配，则二者均右移，不需要操作DOM顺序，继续新一轮循环 若旧startIndex 与 新endIndex 匹配，则说明处于当前对比区间最后面，将DOM节点移动到旧endIndex之后。新endIndex左移，继续新一轮循环。 若旧endIndex 与 新startIndex 匹配，则说明处于当前对比区间的最前面，将DOM节点移动到旧startIndex之前。新startIndex右移，继续新一轮循环。 若旧endIndex 与 新endIndex 匹配，则二者均左移，不需要操作DOM顺序，继续新一轮循环。 若以上都不满足，则根据当前查找区间的key:index映射寻找新startNode对应的旧index。 若找到匹配元素对应位置为idxInOld，则将idxInOld对应的DOM节点移动到旧startIndex前面。新startIndex右移，继续新一轮循环。 若找不到，则新建一个DOM节点，插入到旧startIndex前面。新startIndex右移，继续新一轮循环。 若旧startIndex &gt; 旧endIndex，则为新startIndex -&gt; 新endIndex之前所有节点新建DOM节点并按顺序插入父节点的末尾。 若新startIndex &gt; 新endIndex，则删除旧startIndex -&gt; 旧endIndex之前所有节点的DOM节点 transition-group以上分析过程只是普通的节点更新流程。如果一串节点被transition-group包裹，会发生什么呢？ 源码中，如果有transition-group包裹，可复用的DOM节点顺序是不会调整的，只会新增和删除。如以上例子 **[A, B, C, D, E] =&gt; [F, B, A, E, C, G] ** 对比结束后顺序DOM节点顺序将会是: **[F, A, B, C, E, G]**： 接下来是实施过渡的步骤： 记录当前各个DOM节点的边界位置 children更新，触发render，记录旧DOM节点的边界信息（getBoundingClientRect），重新渲染新DOM（对的，没有过渡，直接按照新的顺序渲染） 触发updated钩子，记录新DOM节点的边界信息 遍历所有children cNode，若同时存在新旧位置信息，说明是复用节点，通过transform将位置重新调整到旧位置（对的，立马设置回旧的位置，前面渲染出来的效果时间很短，用户视觉上看不到，可以通过在transition-group组件的updated钩子加断点看到） 通过读取document.body.offsetHeight触发重排 将children所有节点再设置回新位置，并添加过渡类 主线程执行完，开始重排，此时会显示过渡效果 关于transition-group这里有个小问题：为什么transition-group不立即更新DOM节点？ 因为需要一个过渡效果，不能立即切换为终点状态。过渡过程完全交给transition-group处理。 回到一开始的问题为什么key绑定为img值，过渡效果就生效了呢？ 若key绑定为img时，img相同的图片才会被视为相同节点，会被记录移动前后的位置，因此有过渡效果。 若key不绑定，或者绑定为index，那么相同index的图片被视为相同节点，每个节点的位置都没有变化，因此没有过渡效果。","link":"/2019/12/06/vue/learn-node-reuse/"}],"tags":[{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"百度地图sdk","slug":"百度地图sdk","link":"/tags/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BEsdk/"},{"name":"布局","slug":"布局","link":"/tags/%E5%B8%83%E5%B1%80/"},{"name":"fiddler","slug":"fiddler","link":"/tags/fiddler/"},{"name":"https","slug":"https","link":"/tags/https/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"H5","slug":"H5","link":"/tags/H5/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"代理","slug":"代理","link":"/tags/%E4%BB%A3%E7%90%86/"},{"name":"正则","slug":"正则","link":"/tags/%E6%AD%A3%E5%88%99/"},{"name":"权限","slug":"权限","link":"/tags/%E6%9D%83%E9%99%90/"},{"name":"运营后台","slug":"运营后台","link":"/tags/%E8%BF%90%E8%90%A5%E5%90%8E%E5%8F%B0/"},{"name":"base64","slug":"base64","link":"/tags/base64/"},{"name":"防抖节流","slug":"防抖节流","link":"/tags/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"nuxt","slug":"nuxt","link":"/tags/nuxt/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"charles","slug":"charles","link":"/tags/charles/"},{"name":"debug","slug":"debug","link":"/tags/debug/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"Jenkins","slug":"Jenkins","link":"/tags/Jenkins/"},{"name":"组件","slug":"组件","link":"/tags/%E7%BB%84%E4%BB%B6/"},{"name":"条件编译","slug":"条件编译","link":"/tags/%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/"},{"name":"uni-app","slug":"uni-app","link":"/tags/uni-app/"},{"name":"treeShaking","slug":"treeShaking","link":"/tags/treeShaking/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"vue-router","slug":"vue-router","link":"/tags/vue-router/"},{"name":"cdn","slug":"cdn","link":"/tags/cdn/"},{"name":"chunk","slug":"chunk","link":"/tags/chunk/"},{"name":"node-reuse","slug":"node-reuse","link":"/tags/node-reuse/"}],"categories":[{"name":"css","slug":"css","link":"/categories/css/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"网络","slug":"网络","link":"/categories/%E7%BD%91%E7%BB%9C/"},{"name":"H5","slug":"H5","link":"/categories/H5/"},{"name":"html","slug":"html","link":"/categories/html/"},{"name":"nuxt","slug":"nuxt","link":"/categories/nuxt/"},{"name":"思考","slug":"思考","link":"/categories/%E6%80%9D%E8%80%83/"},{"name":"uni-app","slug":"uni-app","link":"/categories/uni-app/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"其它","slug":"其它","link":"/categories/%E5%85%B6%E5%AE%83/"},{"name":"工程化","slug":"工程化","link":"/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"}]}