{"pages":[{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"代码简洁之道","text":"代码简洁之道这篇文章是从掘金上看到的，整理的很不错，故收藏，有比较大的参考价值传送门","link":"/2019/02/04/blogs/code-clean/"},{"title":"flex上中下布局","text":"此文档只是说明如何实现，采用最新的弹性盒子布局规范，对旧写法不做考虑。 盒子组成12345678910&lt;body class=&quot;flex-ver&quot;&gt; &lt;div class=&quot;header red&quot;&gt;header&lt;/div&gt; &lt;div class=&quot;container flex-auto orange&quot;&gt; &lt;div&gt;content&lt;/div&gt; &lt;div&gt;content&lt;/div&gt; &lt;div&gt;content&lt;/div&gt; &lt;div&gt;content&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer blue&quot;&gt;footer&lt;/div&gt;&lt;/body&gt; 步骤步骤一：body元素设置为flex容器，纵向主轴1234.flex-ver { display: flex; flex-direction: column;} 步骤二：header和footer固定高度123456.header { height: 150px;}.footer { height: 100px;} 步骤三：主体区域container设置为占用剩余高度1234.flex-auto { flex-grow: 1; flex-basis: 0%;} 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./flex.css&quot;&gt;&lt;/head&gt;&lt;body class=&quot;flex-ver&quot;&gt; &lt;div class=&quot;header red&quot;&gt;header&lt;/div&gt; &lt;div class=&quot;container flex-auto orange&quot;&gt; &lt;div&gt;content&lt;/div&gt; &lt;div&gt;content&lt;/div&gt; &lt;div&gt;content&lt;/div&gt; &lt;div&gt;content&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer blue&quot;&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;style&gt; .header { height: 150px; } .footer { height: 100px; } .flex-item { height: auto; } .flex { display: flex; flex-direction: row; } .flex-ver { display: flex; flex-direction: column; } .red { background: red; } .blue { background: blue; } .black { background: black; } .orange { background: orange; }&lt;/style&gt;&lt;/html&gt; 整体效果 主体内容高度自适应 底部footer位于文档最底部，即使主体区域高度不足以占满视口，footer依旧贴在底部。 兼容性火狐浏览器未能实现该效果，主体内容的高度根据内容自适应的，body的整体高度有可能低于视口高度。 解决火狐浏览器兼容性问题注意，html不要设置为overflow: hidden，要设置为overflow:visible。 12345678910html, body , div { padding: 0; margin: 0;}html { height: 100%;}body { min-height: 100%}","link":"/2019/05/10/blogs/flex-layout/"},{"title":"fiddler捕获https包的原理","text":"fiddler代理http协议大家都清楚原理，实际上就是正向代理。正向代理是什么呢？简单来说，就是，一方面，fiddler对浏览器客户端伪造成服务器，另一方面对真实的服务器伪造成客户端。 那么，https作为一种双向验证机制的协议，是如何让fiddler实现抓包的呢？ https其实就是比http多了个加密和解密的过程。 https的作用，其实依赖于证书的信任机制。受信任的证书机构向服务端颁发CA证书，浏览器以及系统默认保存了该机构的根证书。 fiddler其实是自己造了一个证书，如果想抓客户端的流量，就需要客户端手动信任该证书。这也是https抓包的关键。 具体步骤如下图：","link":"/2020/10/01/blogs/https-through-fiddler/"},{"title":"https密钥交换与数据传输","text":"https协议需要同事保证数据的私密性，也要保证完整性。也就是书，既要防止被解密，也要防止被篡改。 保证私密性私密性通过对称密钥加密来实现。所以，关键是要双方共享对称密钥（即下文的k），同时防止第三方拿到这个密钥。 双方共享对称密钥的过程即下图的“交换密钥”。 保证完整性虽然第三方没有办法解密截获的内容，但是它却可以对截获的内容进行篡改再发出去。https是如何做到识别篡改的呢？ https的加密算法含有消息认证机制。数字摘要是采用单项Hash函数将需要加密的明文“摘要”成一串固定长度（128位）的密文，这一串密文又称为数字指纹(fingerprint)，它有固定的长度，而且不同的明文摘要成密文，其结果总是不同的，而同样的明文其摘要必定一致。“数字摘要“是https能确保数据完整性和防篡改的根本原因。 所以只要对内容稍有改动，算出来的指纹就和原来的指纹不一样了，这样就可以知道内容已经被篡改过，不可信了。 所以，综上，双方是约定来一套机制验证数据的完整性，但是不能恢复被篡改的数据。","link":"/2020/10/02/blogs/https/"},{"title":"in 操作符","text":"用来判断对象中是否拥有某个属性。 使用场景for 循环12345let obj = {a: 1, b:2, c:3}for(let key in obj) { console.log(obj[key])} 判断是否有某个属性1234let obj = {a: 1, b:2, c:3}if('a' in obj) { console.log('obj has property &quot;a&quot;')} 和 hasOwnProperty的区别1in操作符可以判断所有可以通过点操作符访问到的属性，即可以访问对象本身以及原型链上的属性。hasOwnProperty只能判断实例拥有 的属性，不能判断原型链上的属性。 由于原型链上的属性是只读的，所以delete操作符只能删除属于对象本身的属性。","link":"/2020/03/20/blogs/in-operator/"},{"title":"linux常见命令","text":"查看端口占用情况 sudo netstat -apn | grep 80 最后一列可以看到进程号 查看ngin端口启用状态： ps -ef | grep nginx 查看端口进程上一步的进程号可以查出是哪个应用占用了端口 ps -ef | grep 3345 杀掉进程 sudo kill -9 3345 -9只是一个信号，表示强制终止，不管正在终止的进程在做什么 查看或编辑nginx配置12vi /usr/local/nginx/conf/nginx.confvi nginx.conf 重启服务器： /usr/local/nginx/sbin/nginx -s reload 连接远程服务器:ssh root@192.168.1.1 上传文件夹到远程目录：scp -r /usr/xxx root@192.168.1.1:/opt/project这个命令执行的结果是，xxx目录会存在于服务器project目录下 删除文件夹： rm -rf dist 移动所有文件到上一个目录： mv * ../ 查看当前目录： pwd 查看用户： cat /etc/passwd 查看用户组： cat /etc/group 查看用户属于哪个组： id root","link":"/2019/12/06/blogs/linux-command/"},{"title":"移动端meta","text":"viewport1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes,minimal-ui&quot;&gt; MobileOptimized告诉浏览器页面为某个宽度特殊优化 (微软系) 1&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot; /&gt; HandheldFriendly告诉浏览器页面是否为手持设备优化，会被MobileOptimized覆盖 (旧浏览器和功能机上某些浏览器识别) 1&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot; /&gt; Apple私有12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!-- iOS 设备 begin --&gt; &lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt; &lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt; &lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --&gt; &lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt; &lt;!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） --&gt; &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;/&gt; &lt;!-- 设置苹果工具栏颜色 --&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;/&gt; &lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt; &lt;!-- 启用360浏览器的极速模式(webkit) --&gt; &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; &lt;!-- 避免IE使用兼容模式 --&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt; &lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt; &lt;!-- 微软的老式浏览器 --&gt; &lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt; &lt;!-- uc强制竖屏 --&gt; &lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt; &lt;!-- QQ强制竖屏 --&gt; &lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt; &lt;!-- UC强制全屏 --&gt; &lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt; &lt;!-- QQ强制全屏 --&gt; &lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt; &lt;!-- UC应用模式 --&gt; &lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt; &lt;!-- QQ应用模式 --&gt; &lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt; &lt;!-- windows phone 点击无高光 --&gt; &lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt; &lt;!-- iOS 图标 begin --&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/apple-touch-icon-57x57-precomposed.png&quot;/&gt; &lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;/apple-touch-icon-114x114-precomposed.png&quot;/&gt; &lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;144x144&quot; href=&quot;/apple-touch-icon-144x144-precomposed.png&quot;/&gt; &lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt; &lt;!-- iOS 图标 end --&gt; &lt;!-- iOS 启动画面 begin --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;768x1004&quot; href=&quot;/splash-screen-768x1004.png&quot;/&gt; &lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1536x2008&quot; href=&quot;/splash-screen-1536x2008.png&quot;/&gt; &lt;!-- iPad 竖屏 1536x2008（Retina） --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1024x748&quot; href=&quot;/Default-Portrait-1024x748.png&quot;/&gt; &lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;2048x1496&quot; href=&quot;/splash-screen-2048x1496.png&quot;/&gt; &lt;!-- iPad 横屏 2048x1496（Retina） --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;/splash-screen-320x480.png&quot;/&gt; &lt;!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x960&quot; href=&quot;/splash-screen-640x960.png&quot;/&gt; &lt;!-- iPhone/iPod Touch 竖屏 640x960 (Retina) --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x1136&quot; href=&quot;/splash-screen-640x1136.png&quot;/&gt; &lt;!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) --&gt; &lt;!-- iOS 启动画面 end --&gt; &lt;!-- iOS 设备 end --&gt; format-detection禁用电话号码和邮箱识别 1&lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot; /&gt; 参考资料：移动端头部meta大全","link":"/2019/05/29/blogs/meta/"},{"title":"纯js实现打印功能","text":"打印其实最终都是调用window.print方法实现打印。只不过，我们通常不是打印整个页面，所以，诞生了各种各样的方法实现部分打印。适配vue框架的打印组件有vuePlugs_printjs和vue-print-nb。这两者实现的方式是一样的，都是使用iframe插入打印区域和对应样式。区别只是使用方式的区别。 那么，我也实现了一个原生js实现的打印功能。 一、新建iframe窗口为了打印出想要的部分，我们需要新建一个窗口，把需要的dom装进去。为了避免部分浏览器阻止窗口弹出导致无法打印，建议使用iframe。 打印的时候，我们需要防止iframe的显示影响页面布局，只需要在父页面设置iframe的样式为display: none即可。如下： 123const frame = document.createElement('iframe')frame.style.display = 'none'document.body.appendChild(frame) 二、选择需要打印的部分dom从当前dom选择需要打印的dom元素，插入iframe。 1234let target = document.getElementById('print-target')if (target) { frame.contentDocument.body.innerHTML = target.outerHTML} 三、插入样式一般情况下，你可以直接将父页面的style和link全部拷贝到iframe中，这样打印到样式和原本样式是一样的，除非打印部分的样式受未打印部分的父元素控制导致样式脱节，所以，打印部分的样式尽量和父元素解耦。 我们知道，浏览器打印的时候你可能需要不一样的样式，只需要加多一个style标签引入打印样式即可。比较典型的就是，打印的时候你想要按照需要打印的纸张尺寸打印，这时候可以在@media print中将容器的宽度改为打印尺寸（如A4是210mm，css支持mm单位的尺寸）。 四、特殊元素处理由于我们将打印区域拷贝到ifame中采用对的是将targetElement.outerHTML赋值给iframe的body的。这样赋值的情况下，部分表单组件会失去值，所以，我们需要在赋值之前将值固定，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041// https://github.com/Power-kxLee/vue-print-nb/blob/master/src/packages/printarea.jslet copy = ele.cloneNode(true);let copiedInputs = copy.querySelectorAll('input,select,textarea');let selectCount = -1;for (let i = 0; i &lt; copiedInputs.length; i++) { let item = copiedInputs[i]; let typeInput = item.getAttribute('type'); let copiedInput = copiedInputs[i]; // 获取select标签 if (!typeInput) { typeInput = item.tagName === 'SELECT' ? 'select' : item.tagName === 'TEXTAREA' ? 'textarea' : ''; } // 处理input框 if (item.tagName === 'INPUT') { // 除了单选框 多选框比较特别 if (typeInput === 'radio' || typeInput === 'checkbox') { copiedInput.setAttribute('checked', item.checked); // } else { copiedInput.value = item.value; copiedInput.setAttribute('value', item.value); } // 处理select } else if (typeInput === 'select') { selectCount ++; for (let b = 0; b &lt; ele.querySelectorAll('select').length; b++) { let select = ele.querySelectorAll('select')[b]; // 获取原始层每一个select !select.getAttribute('newbs') &amp;&amp; select.setAttribute('newbs', b) // 添加标识 if (select.getAttribute('newbs') == selectCount) { let opSelectedIndex = ele.querySelectorAll('select')[selectCount].selectedIndex; item.options[opSelectedIndex].setAttribute('selected', true); } } // 处理textarea } else{ copiedInput.innerHTML = item.value; copiedInput.setAttribute('html', item.value); }}","link":"/2019/08/20/blogs/print/"},{"title":"html property &amp; attribute","text":"propertyDOM元素的属性，如selectedIndex, tagName, nodeName, nodeType, ownerDocument, defaultChecked, defaultSelected DOM是提供给js访问页面元素的对象 attributeHTML标签上绑定的属性，包括id, value, name, type，除了value之外，其它属性基本都是字符串类型的 JQuery的attr()和prop()方法的区别prop()就是获取property属性的值，attr()是获取attribute的值如果要改变DOM的值，获取会发生变化的属性值，需要调用prop()方法，比如checked, selected, or disabled1&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt; 对于以上标签，获取值对应关系如下： 123456elem.checked true (Boolean) Will change with checkbox state$( elem ).prop( &quot;checked&quot; ) true (Boolean) Will change with checkbox stateelem.getAttribute( &quot;checked&quot; ) &quot;checked&quot; (String) Initial state of the checkbox; does not change$( elem ).attr( &quot;checked&quot; ) (1.6) &quot;checked&quot; (String) Initial state of the checkbox; does not change$( elem ).attr( &quot;checked&quot; ) (1.6.1+) &quot;checked&quot; (String) Will change with checkbox state$( elem ).attr( &quot;checked&quot; ) (pre-1.6) true (Boolean) Changed with checkbox state","link":"/2018/07/03/blogs/property-attribute/"},{"title":"proxy 与 reflect","text":"Proxy定义 在目标对象上架设一个拦截层， 外界对该对象的访问先经过这一个拦截层，这个拦截层可以对外界对访问进行过滤和改写。翻译为代理器。 举个拦截和改写例子： 12345678let proxy = new Proxy({}, { get: function() { return 35 }})proxy.time // 35proxy.name // 35 上面对代码拦截了一个空对象的属性getter。只要是需要访问到对象的属性，都会触发getter。 Proxy 能拦截哪些访问行为呢？ 拦截行为 触发条件 返回值说明 get(target, propKey, receiver) 读取对象属性，proxy.foo，proxy[‘foo’] 返回属性值 set(target, propKey, value, receiver) 设置对象属性，proxy.foo = v，proxy[‘foo’] = v 返回一个布尔值，表示是否设置成功 has(target, propKey) propKey in proxy的操作 返回一个布尔值，表示是否包含此属性 deleteProperty(target, propKey) delete proxy[propKey] 返回一个布尔值，表示是否删除成功 ownKeys(target) Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环 返回目标对象所有自身的属性的属性名 getOwnPropertyDescriptor(target, propKey) Object.getOwnPropertyDescriptor(proxy, propKey) 返回属性的描述对象 defineProperty(target, propKey, propDesc) Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs) 返回一个布尔值表示是否定义成功 preventExtensions(target) Object.preventExtensions(proxy) 返回一个布尔值表示是否定义成功 getPrototypeOf(target) Object.getPrototypeOf(proxy) 返回一个对象（对象原型） isExtensible(target) Object.isExtensible(proxy) 返回一个布尔值 setPrototypeOf(target, proto) Object.setPrototypeOf(proxy, proto) 返回一个布尔值 apply(target, object, args) 拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…) 无限制 construct(target, args) 拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args) 返回实例对象 Reflect定义 将Proxy支持的代理方法一一对应到Reflect，方便在Proxy中使用原对象的默认行为。 12345678910let proxy = new Proxy(target, { set: function(target, name, value, receiver) { var success = Reflect.set(target, name, value, receiver); if (success) { console.log('property ' + name + ' on ' + target + ' set to ' + value); } return success; }});proxy.a = 1 某些方法和Object原型方法行为高度一致，所以，除了在Proxy中使用，还可以单独使用。 1234567891011121314// 老写法try { Object.defineProperty(target, property, attributes); // success} catch (e) { // failure}// 新写法if (Reflect.defineProperty(target, property, attributes)) { // success} else { // failure} 谁在用Vue设置内置属性只读设置内置keyCode为只读： 123456789101112131415161718const hasProxy = typeof Proxy !== 'undefined' &amp;&amp; Proxy.toString().match(/native code/) if (hasProxy) { const isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact') config.keyCodes = new Proxy(config.keyCodes, { set (target, key, value) { if (isBuiltInModifier(key)) { warn(`Avoid overwriting built-in modifier in config.keyCodes: .${key}`) return false } else { target[key] = value return true } } }) } 1Vue.config.keyCodes.ctrl = 86 以上代码会报错： 测试框架和defineProperty什么关系？什么时候适合用？","link":"/2020/03/15/blogs/proxy-reflect/"},{"title":"正向代理和反向代理的区别","text":"正向代理位于客户端和服务器之间的代理服务器，对服务器不可见。 客户端可以访问该代理服务器，但是客户端不直接访问代理背后的服务器，或者客户端根本没办法访问代理背后的服务器。 客户端需要明确指定代理服务器的地址。以及可能需要身份认证来限制其它客户端随意访问。 正向代理比较常见的使用场景是翻墙，局域网抓包。 反向代理隐藏于服务器背后，对客户端不可见 客户端访问的服务器本身就是反向代理服务器，只是客户端不知情。反向代理服务器将客户端的请求代发给其背后的服务器，拿到结果并传回给客户端。 反向代理比较常见的场景是本地代码调试线上接口，表面访问本地接口，但是由本地反向代理服务器将接口转发到线上地址以解决接口跨域问题。另外一个常用的场景是服务器负载均衡，以及外网灰度发布。 外网灰度发布举个例子，反向代理负责将请求转发给3个服务器，这3个服务器上的代码有一个是旧版本，另外2个是新版本。代理服务器将某些ip段客户端的请求转发给旧版本，其它的转发给新版本。这样就可以达到灰度发布的效果。","link":"/2020/03/17/blogs/proxy/"},{"title":"有趣的正则表达式","text":"字符串拼接假设有这样一种场景： 有三个字符串类型的变量，姓名(name)，性别(sex)，年龄(age)。想把这三个变量值用逗号拼接成1个字符串userInfo。 常规的方法可能就是类似这样： 1let userInfo = `${name}，${sex}，${age}` 问题是，这三个变量可能都为空。你肯定不希望userInfo是”，，10”或者”小明，，10”或者”，，” 简单的思考后你可能会这样做： 1234let userInfo = ''name ? userInfo += name + '，' :sex ? userInfo += sex + '，':age ? userInfo += age + '，': 本着足够懒的想法，仔细考虑了一番之后，我总结出的规律就是： 开头结尾的连接符删除 中间有2个或以上的连接符都要删减至1个 所以可以这样写： 1let userInfo = `${name}，${sex}，${age}`.replace(/(^，)|(，$)/g, '').replace(/，{2,}/, '，')","link":"/2019/04/16/blogs/regexpression/"},{"title":"base64字符串保存","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt;//方法1function saveAsLink(base64Str) { var a = document.createElement('a'); // 转换完成，创建一个a标签用于下载 a.download = fileName; a.href = 'data:application/msword;base64,' + base64Str; a.style.display = 'none'; document.body.appendChild(a) // 修复firefox中无法触发click a.click(); document.body.removeChild(a)}saveAsLink(fileBse64Str)//方法2(firefox浏览器不兼容)var blob = new Blob([_base64ToArrayBuffer(fileBse64Str)], {type: 'application/msword'}), fileName = '文件名称.doc'function _base64ToArrayBuffer(base64) { var binary_string = window.atob(base64); var len = binary_string.length; var bytes = new Uint8Array( len ); for (var i = 0; i &lt; len; i++) { bytes[i] = binary_string.charCodeAt(i); } return bytes.buffer;}function downFile(blob, fileName) { if (window.navigator.msSaveOrOpenBlob) { navigator.msSaveBlob(blob, fileName); } else { var link = document.createElement('a'); debugger link.href = window.URL.createObjectURL(blob); link.download = fileName; link.click(); window.URL.revokeObjectURL(link.href); }}downFile(blob, fileName)&lt;/script&gt;&lt;/html&gt;","link":"/2020/05/08/blogs/save-base64/"},{"title":"防抖和节流","text":"防抖短时间内连续触发的事件，不执行回调，给定一个冷却时间，这段时间内没有触发则时间结束后执行回调。即，持续触发不执行，不触发一段时间之后再执行。 常见场景： 输入框持续输入，输入内容远程查询 多次触发点击事件 滚动后获取滚动距离 12345678910const debounce = function (func, delay) { let timer = null return function() { clearTimeout(timer) timer = setTimeout(() =&gt; { func(...arguments) }, delay || 300) }} 节流函数一段时间内只执行一次。即，持续触发并不会执行多次，到一定时间再去执行。通过闭包保存开关状态。常见场景： 自定义滚动条 页面resize 12345678910111213141516const throttle = function (func, delay) { let run = true return function () { if (!run) { // 如果开关关闭了，那就直接不执行下边的代码 return } // 持续触发的话，run一直是false，就会停在上边的判断那里 run = false func(...arguments) // 定时器到时间之后，会把开关打开，我们的函数就会被执行 setTimeout(() =&gt; { run = true }, delay) }} 以上方法使用的时候需要注意，由于返回的是函数，所以throttle或debounce只能调用一次。以Vue为例： 12345678910111213onPageScroll(e) { if (!this.$options.throttleFunc) { this.$options.throttleFunc = throttle((scrollTop) =&gt; { if(scrollTop &gt; 30) { this.scrollStatus = true } else { this.scrollStatus = false } }, 100) } this.$options.throttleFunc(e.scrollTop)} 参考资料:知乎：函数的防抖和节流是个啥？？？","link":"/2021/05/31/blogs/throttle-debounce/"},{"title":"nuxt导航共用","text":"导航作为多个页面之间共用的部分，一般是动态的，即每个页面返回之前需要异步请求。 服务端异步请求的方法有asyncData，fetch。但是这俩方法都只支持页面组件，不支持layout中使用。 所以，我们只能用vuex作为中转站，将页面组件获取的导航信息存储到vuex中。layout再从vuex中获取。 layout/default 1234567891011121314import navigator from '@@/navigator/index.vue'export default { name: 'Music163', components: { navigator }, data () { return { } }, computed: { menus () { return this.$store.state.menu.menus } }} pages/index 12345export default { fetch ({ store, params }) { store.dispatch('menu/GET_MENU') }} store/menu 123456789101112131415161718192021export const state = () =&gt; ({ menus: []})export const mutations = { SET_MENU (state, menus) { state.menus = menus }}export const actions = { GET_MENU (store, menus) { const data = [{ title: '发现音乐' }, { title: '我的音乐' }] store.commit('SET_MENU', data) }}","link":"/2020/01/20/nuxt/navigator/"},{"title":"一次技术方案的分析过程","text":"分析技术方案时，保持以终为始的原则。思维就像一棵树，方案就像树枝，遍历之后发现不可行，只需要往根部回溯，重新思考达到目标的其它方法。 背景这是我负责的一个H5项目，内嵌于APP的webview，页面跳转通过打开新的webview来实现类app的效果。 在app内从另外一个项目跳转到该应用时，需要带上一个sourceid，标记引流入口。sourceid可能是来源于首页或者商品详情页，只有在下单的时候会提交给订单。 任务对该sourceid生命周期的要求是： 外部项目跳转进入该项目之后，到关闭由它打开的所有页面为止，算一个生命周期。 行动从页面跳转传参入手app为和提供了桥接sdk，应用内webview调用的是同一个api，打开新窗口前可以使用proxy拦截该api，获取当前窗口的链接，将链接上的sourceid带到新窗口上，实现sourceid参数的透传。 这个方法简单粗暴，却有明显的缺点： 业务和工具耦合，不利于维护 分享转发前需要把该参数去掉，会影响到旧的逻辑 该方法可行，但是属于对公共代码的修改，容易引发bug，暂时纳入备选方案。 从本地存储方案入手浏览器本地缓存方案有localstorage、sessionStorage、cookie。这些方案在webview中是否也适用呢？ 经过在ios中验证localstorage的缓存行为和浏览器类似，sessionStorage和cookie在webview之间不共享，因此2者被排除。 请教了ios客户端的同事，了解到，ios平台的app目前使用的是WKwebview实现，窗口之间使用的是不同的WKProcessPool，所以数据共享是个问题，localstorage之所以看起来像是共享了，实际上只是在打开同源窗口时复制了一份，新开的窗口对localStorgae所做的修改不会对旧窗口有影响。这些问题在以前UIwebview开发的时代是不存在的，而UIwebview的是因为内存占用过高而逐渐被淘汰。 可共享的存储方案就只剩下localstorage。由于localstorage属于持久化存储，想要识别一次完整使用，需要抓住一个边界点：要如何识别一次完整使用，是否具有开始或者结束的标志。在这个边界点更新sourceid 完整使用的标志有： 该webview是应用中当前存在的唯一本项目的webview，标记一次使用的开始 应用中当前存在的唯一本项目的webview被销毁，标记一次使用的结束 这2种标志如何去标记呢？我想到了以下办法： app提供相关api告诉我们是否是同源webview的第一个页面，就像微信小程序那样，打开非首页的头部左上角会显示一个home按钮。很遗憾没有找到相关api。 像window.onbeforeunload那样监听页面销毁，存储过sourceid的页面在页面销毁前销毁缓存的sourceid。通俗来讲，就是自产自销（销毁）。经测试发现，webview关闭并不会触发window.onbeforeunload和onunload事件。该方法不可行。 不那么完美的实现方案当没有完美的解决方案时，问自己，我们真的一定要完美的实现吗？经过和产品的讨论，产品方认为，不需要。可以根据用户的使用习惯，大致确定sourceid的合理有效时间，通过localstorage实现超时清理方案。 结论又一个很简单的决策公式：决策 = 收益 - 成本 - 风险以下列出了暂时可行的方案评估表： 方案 收益 成本（开发） 风险（上线+后期维护） 决策 proxy拦截api添加参数 10 3 1+1 5 localstorage有效期 8 1 0+0 7 根据上表的结果，最终选择了“localstorage有效期”这个方案。","link":"/2021/05/10/think/fanganfenxi/"},{"title":"四象限时间管理","text":"史蒂芬·科维的《高效能人士的七个习惯》在描述如何实现个人领域成功时提到了一个很重要的习惯，“要事第一”。 通常我们列出来的TODO list是线性的，从上至下排列，我们的评判标准只有一个：是否重要。 一、2个维度 4个象限2个维度： 是否重要 重要性对一个人来说要从价值观的角度去考虑。这件事做了之后是否有收获，这个收获一定要对自己有意义。 通常大家觉得，让自己有收获的事情才是最重要的。我觉得，工作期间和工作之余要区分开来。即在该做什么事情的时候就做什么事情。所以，针对工作和生活可以使用2份4象限表。 是否紧急 在近期内必须要完成的，即紧急的 一般比较紧急的是有deadline的事情。 工作上的例子：项目上线，会议前的方案搜集 生活中的例子：上学，煮饭 4个象限： 重要且紧急 重要不紧急 不重要但紧急 不重要不紧急。 二、如何区分事件属于哪个象限？以下针对4个象限的界定标准进行描述。 重要&amp;紧急 (Urgent &amp; Important)这个象限内的事情可以说不得不做。生活中应该尽量避免堆积太多此类事情，否则整日焦头烂额。 不立即做的话将来随时可能产生危机 必须在deadline之前赶出来，这个deadline强调外界压力 重要&amp;不紧急 (Important &amp; Not Urgent) 有助于个人长远发展的事情， 比如学习计划，技术方案调研 有助于群体长远发展的事情，比如培训计划 有助于减少“重要紧急”事项的事情。 我们通常说，有拖延症的人通常指，把重要但是不紧急的事情拖延到演变为重要紧急的事情，导致花更多的时间在第一象限。 紧急&amp;不重要 (Urgent &amp; Not Important) 需要近期做的事情，迫不得已可以选择不做或者接受延期的 时间比较赶，但是不怎么耗费精力 这类工作最好做，但是在精力状态一般的情况下做，必要的时候选择不做。这样可以充分利用以及节约时间。这类事情包括约会，群体活动，回复邮件。 不重要&amp;不紧急 (Not Important &amp; Not Urgent) 纯粹打发时间，没有任何实际意义 短期精神满足，实则空虚 这类事情在其它象限的事情没有处理完的时候尽量不要做。除非其它象限的事情完全没有精力做下去了又不想休息。 三、如何实施1、针对列出的任务清单，问自己2个问题： 这件事情，真的很重要吗？如果是工作任务，是否属于高优先级的任务？如果是学习任务，是否能让自己有所收获？所需要的时间是多久？ 通过以上问题，把任务分成重要和不重要的，相同类别下的任务分别赋值一个重要指数。 这件事情你自己计划或者上级需要什么时候完成？写下deadline，给自己定下的deadline最好比实际要求的更早。 通过以上问题，把最近1周内需要做的事情按照deadline进行排序，其它的事情暂时安排到下周。如果任务需要花的时间比较长，最好做一下任务分解，说不定可以分解出一些可以延后的任务。 2、针对排好的任务进行象限组合、排序把每个任务放到所属的象限内，并根据2个维度的指数进行象限内排序。 3、执行顺序大体上任务的执行顺序按照 重要&amp;紧急，重要&amp;不紧急，紧急&amp;不重要，不紧急不重要 的顺序来。 但是，如果你是替别人打工，有些工作上“不重要且紧急”的事情需要排在“重要&amp;不紧急”的事情前面，往往前者比后者更加耗时间，所以可以选择在前者的间隙处理后者。 4、每日调整&amp;总结安排总会因为各种原因变化，我们要重视对任务重新梳理的过程，以免做无用功。 不要每天给自己安排过多的任务，总结的时候发现没有按时完成任务会带来懊悔和自我否定。合理的安排比压榨自己更加划算。","link":"/2019/04/09/think/manage-time/"},{"title":"charles 重写请求","text":"charles 和fiddler既然都可以拦截返回体，没有理由不可以拦截请求是不是？ 我这里只说charles吧。 配置重写域名 进入菜单 Tools -&gt; Rewrite 可见如下界面 点击sets 区域的Add按钮添加重写任务。 在右侧的Locations区域点击Add按钮添加需要重写的请求的域名 配置域名下的重写规则 选中上一个步骤中添加的域名，在Rules区域点击Add按钮 在Type项那里选择重写类型 有以上几种类型可供选择。从上图可以看出来，重写规则可以重写请求头部和请求体，也可以重写返回头部和返回体。 这个功能不仅能调试身份认证信息，还能调试跨域网站，以及接口数据。 在Match和Replace区域配置重写规则 上图将请求头部uniType的值替换为105，仅当uniType的值为101的时候才替换。","link":"/2020/02/01/tools/charles-rewrite-header/"},{"title":"抓包工具调试线上代码","text":"web应用代码混淆和压缩可以一定程度上缩短代码的请求时间，从而提高页面的访问体验，但是却不方便调试。这里教大家使用抓包工具调试线上代码。 以下方法假设你已经成功用fiddler或者charles代理你要调试的线上应用。 fiddler拦截客户端代码很久以前遇到一个线上问题，本地不能复现，而且还是手机浏览器环境，而且客户端报错日志找不到相关的问题。当时想到的调试方法就是使用fiddler修改返回的js代码，开启vconsole的debug模式查看页面报错信息。这个方法其实就是拦截返回js并正则匹配内容进行修改。 局部修改使用fildder可以拦截http返回内容并修改。 1.打开CustomRules.js点击fiddler的Rules=&gt;Customize Rules，FiddlerScript editor工具就会自动的打开CustomRules.js文件。 2.修改 OnBeforeResponse 函数假如，我想把http://my.example.com/index.html 资源返回代码中的”vconsole.debug = false”改为”vconsole.debug = true”，只需要在这个函数中插入一个if语句。可以这样写： 12345//判断Url内容中是否包含特定内容，针对这个Url进行下面的操作if (oSession.uriContains(&quot;my.example.com/index.html&quot;)) { oSession.utilDecodeResponse(); oSession.utilReplaceInResponse(&quot;vconsole.debug = false&quot;, &quot;vconsole.debug = true&quot;);} 这个方法比较难操作，毕竟你需要先找到要修改的代码，确保需要替换的内容是独一无二的，而且，如果想修改替换内容需要重新修改替换逻辑。更加简单粗暴的方法是直接下载代码下来，将这个资源代理到本地，想怎么修改就怎么修改。 fiddler将代码代理到本地1.找到你需要代理的请求 标黄的请求就是目标请求，拖拽到右侧的AutoResponse标签中 2.选中代理选项勾选右侧AutoResponse标签中的 Enable rules：开启重定向使规则生效，指的是代理到本地这个规则。 Umatched requests passthrough:不影响那些没满足我们处理条件的请求通过。 3.选择需要代理的到的本地文件上图右侧选中第一步拖进去的请求，并在右下角的Rule Editor中的第二个下拉框选择Find a file。此时会打开本地资源管理器要求你选择文件。 4.修改代码刷新页面修改上一步你选中的代码，保存之后刷新你要调试的页面，重新加载的资源就回变成你本地的资源。 charles拦截客户端代码设置map local在请求中找到需要调试的代码文件，右键，菜单中选择 Map Local弹窗中选择需要映射到的本地文件点OK即可。 重新请求对应的资源发现已经是本地的代码文件了。这时候可以随意的修改代理到的本地文件调试。 取消map在Tools-&gt;Map Local菜单下可以删除刚刚添加的map。","link":"/2020/02/02/tools/fiddler-debug-online/"},{"title":"git 常用命令","text":"本地代码新建远程仓库如果本地配置的ssh 是其它域名下的，比如说公司内网gitlab，但是你此时想要创建的仓库是github上的，那代码推到远程仓库的时候需要使用https协议，而不是ssh，不然的话身份认证会失败的。 1git@github.com: Permission denied (publickey). 远程：创建一个仓库， 假如链接为 1https://github.com/sharemeans/vue.git/ 本地：12345678cd my-vuegit initgit add .git commit -m &quot;项目初始化&quot;git remote add origin https://github.com/sharemeans/vue.git/// 根据提示输入账号密码，成功之后代码自动上传// 代码推送到远程 -u表示推送成功后自动建立本地分支与远程分支的追踪git push -u origin master 查看远程仓库地址1git remote -v 查看本地分支跟踪的远程分支1git branch -vv 基于远程分支A创建本地跟踪分支A1git checkout -b A origin/A 基于本地分支B创建本地分支A1git checkout -b A B 基于远程分支创建本地同名跟踪分支1git checkout --track origin/A 合并A 分支到当前分支，且所有冲突都采用A分支1git pull -s recursive -X theirs A","link":"/2019/12/01/tools/git/"},{"title":"插件Pipeline: Groovy","text":"Jenkins 自动化构建基于一系列插件，常用的插件 最基础的是流水线插件。公司内的流水线插件配置使用Pipeline: Groovy。该插件的基本配置如下。 可以直接在文本框写入简单的脚本（Pipeline script），也可以读取Jenkinsfile内的流水线脚本（Pipeline script from scm）。scm全称是Source Control Management，如gitlab。 选择了SCM之后需要配置git的地址和账号密码： 选择构建分支： 构建分支BRANCH的值来源于参数，需要配置参数化构建，Jenkins可配置的参数类型有： 其中，Git Parameter类型需要安装插件：Git Parameter。 该插件获取以下类型的值，并赋值给我们定义的变量名BRANCH（可以是其它名字）： 分支选择时可以配置过滤器以及分支显示框的高度： 另外可以配置其它参数，如构建环境：checkbox类型的值传入Jenkinsfile中的格式为字符串，分隔符和Jenkins上的配置一致。 Jenkinsfile中可以通过params 获取到参数化构建中传入的参数： 选择构建分支时，可以使用参数化构建传入的参数： pipeline:Groovy可以配置构建执行脚本文件路径：","link":"/2021/04/30/tools/pipeline-groovy/"},{"title":"uni-app 小程序自定义图标组件","text":"图标组件支持的功能： 图标颜色 图标名称 图标边距 图标大小 事件类型 事件名称 事件描述 click 点击事件 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!--图标组件&lt;com-icons name=&quot;icon-location&quot; size=&quot;28rpx&quot; padding=&quot;0 10rpx&quot; color=&quot;#ffffff&quot;&gt;&lt;/com-icons&gt;--&gt;&lt;template&gt; &lt;text class=&quot;uni-icons iconfont&quot; :class=&quot;name&quot; :style=&quot;{ fontSize: size, color: color, padding: padding }&quot; @click=&quot;_onClick&quot;&gt;&lt;/text&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'uni-icons', props: { name: { // 图标类型，拼接前缀icon- type: String }, size: { // 图标大小 type: String, default: 'inherit' }, color: { // 图标颜色 type: String, default: 'inherit' }, padding: { // 内边距 type: String, default: '0' } }, methods: { _onClick() { this.$emit('click') } }}&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt; @import 'path-to/iconfont.less';&lt;/style&gt;","link":"/2020/11/20/uni-app/com-icons/"},{"title":"uni-app 小程序自定义导航栏组件","text":"该组件是基于uni-ui扩展组件uni-nav-bar修改。导航组件严格来说是有2个组件组成：状态栏组件，头部组件 getStatusBarHeight和getMenuButtonBoundingClientRect方法可以获取小程序状态栏和头部胶囊信息，取值关系如下： 需要注意的是，通过getMenuButtonBoundingClientRect方法top属性一般比getStatusBarHeight的值大，且不同设备具体差异大小不同。 关于状态栏组件，具体搜索文章小程序状态栏组件。 导航组件该组件依赖于以下组件： com-icons iconfont组件 com-status-bar 状态栏组件 以上组件可通过搜索名称查找相关代码。 导航组件具有以下功能： 滚动头部固定/跟随文档 自定义返回按钮、按钮后的文案、左侧/右侧区域宽度 头部固定时是否需要保持高度（避免业务方做高度兼容） 头部透明度（支持头部随着滚动过渡） 是否需要状态栏 自定义返回按钮点击行为 小程序环境自动判断是否需要显示回到首页按钮 事件类型 事件名称 事件描述 clickLeft 点击左侧区域 clickRight 点击右侧区域 方法 方法名称 方法描述 getHeight 获取导航高度 使用时需要修改以下功能： icon组件对应的icon字体需要根据具体的应用修改 HOME_PATH对应的值根据具体的应用修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413&lt;template&gt; &lt;view class=&quot;uni-navbar&quot;&gt; &lt;view :class=&quot;{ 'uni-navbar--fixed': fixed, 'uni-navbar--shadow': shadow, 'uni-navbar--border': border }&quot; :style=&quot;{ 'background': backgroundColor, opacity: opacity }&quot; class=&quot;uni-navbar__content&quot;&gt; &lt;com-status-bar v-if=&quot;statusBar&quot; /&gt; &lt;view :style=&quot;{ color: color,background: backgroundColor, height: headerHeight, lineHeight: headerHeight }&quot; class=&quot;uni-navbar__header uni-navbar__content_view&quot;&gt; &lt;!-- 左侧（默认点击行为：返回上一页。可重写） --&gt; &lt;view @click=&quot;onClickLeft&quot; class=&quot;uni-navbar__header-btns uni-navbar__header-btns-left uni-navbar__content_view&quot; :style=&quot;{width: leftIconWidth}&quot;&gt; &lt;!-- 回到首页按钮（分享场景）（与其它按钮或者文案互斥） --&gt; &lt;!-- #ifdef MP-WEIXIN --&gt; &lt;view class=&quot;uni-navbar__content_view&quot; :class=&quot;{'header-icon-with-bg': showIconBg}&quot; v-if=&quot;showHome&quot; @click=&quot;goHome&quot;&gt; &lt;com-icons :color=&quot;color&quot; name=&quot;icon132&quot; size=&quot;40rpx&quot; /&gt; &lt;/view&gt; &lt;!-- #endif --&gt; &lt;!-- 返回按钮 --&gt; &lt;view class=&quot;uni-navbar__content_view&quot; :class=&quot;{'header-icon-with-bg': showIconBg}&quot; v-if=&quot;!showHome &amp;&amp; leftIcon &amp;&amp; showLeftBack&quot; &gt; &lt;com-icons :color=&quot;color&quot; name=&quot;icon9&quot; size=&quot;40rpx&quot; /&gt; &lt;/view&gt; &lt;!-- 左侧显示文案 --&gt; &lt;view class=&quot;uni-navbar-btn-text uni-navbar__content_view&quot; :class=&quot;{ 'uni-navbar-btn-icon-left': leftIcon }&quot; v-if=&quot;!showHome &amp;&amp; leftText.length&quot;&gt; &lt;text :style=&quot;{ color: color, fontSize: '28rpx' }&quot;&gt;{{ leftText }}&lt;/text&gt; &lt;/view&gt; &lt;!-- 左侧区域插槽（具名插槽） --&gt; &lt;slot name=&quot;left&quot; /&gt; &lt;/view&gt; &lt;!-- 标题区域 --&gt; &lt;view class=&quot;uni-navbar__header-container uni-navbar__content_view&quot;&gt; &lt;view class=&quot;uni-navbar__header-container-inner uni-navbar__content_view&quot; v-if=&quot;title.length&quot;&gt; &lt;text class=&quot;uni-nav-bar-text&quot; :style=&quot;{color: color }&quot;&gt;{{ title }}&lt;/text&gt; &lt;/view&gt; &lt;!-- 标题插槽（无名插槽） --&gt; &lt;slot /&gt; &lt;/view&gt; &lt;!-- 右侧按钮区域 --&gt; &lt;view @tap=&quot;onClickRight&quot; class=&quot;uni-navbar__header-btns uni-navbar__header-btns-right uni-navbar__content_view&quot; :style=&quot;{width: rightIconWidth}&quot;&gt; &lt;view class=&quot;uni-navbar__content_view&quot; :class=&quot;{'header-icon-with-bg': showIconBg}&quot; v-if=&quot;rightIcon&quot;&gt; &lt;com-icons :color=&quot;color&quot; :name=&quot;rightIcon&quot; size=&quot;56rpx&quot; /&gt; &lt;/view&gt; &lt;!-- 优先显示图标 --&gt; &lt;view class=&quot;uni-navbar-btn-text uni-navbar__content_view&quot; v-if=&quot;rightText.length &amp;&amp; !rightIcon.length&quot;&gt; &lt;text class=&quot;uni-nav-bar-right-text&quot;&gt;{{ rightText }}&lt;/text&gt; &lt;/view&gt; &lt;!-- 右侧区域插槽（具名插槽） --&gt; &lt;slot name=&quot;right&quot; /&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 副标题（样式完全自定义） --&gt; &lt;view class=&quot;uni-navbar__sub-header&quot;&gt; &lt;slot name=&quot;sub-nav&quot;&gt;&lt;/slot&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 标题区域占位 --&gt; &lt;view class=&quot;uni-navbar__placeholder&quot; v-if=&quot;fixed &amp;&amp; holdPlace&quot;&gt; &lt;com-status-bar v-if=&quot;statusBar&quot; /&gt; &lt;view class=&quot;uni-navbar__placeholder-view&quot; :style=&quot;{'padding-top': subHeaderHeight, height: headerHeight}&quot;/&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;// 首页路径const HOME_PATH = 'pages/index/index'var CustomNavbarHeight = uni.getCustomNavbarHeight() /** * NavBar 自定义导航栏 * @description 导航栏组件，主要用于头部导航 * @tutorial https://ext.dcloud.net.cn/plugin?id=52 * @property {String} title 标题文字 * @property {String} leftText 左侧按钮文本 * @property {String} rightText 右侧按钮文本 * @property {String} leftIcon 左侧按钮图标（图标类型参考 [Icon 图标](http://ext.dcloud.net.cn/plugin?id=28) type 属性） * @property {String} rightIcon 右侧按钮图标（图标类型参考 [Icon 图标](http://ext.dcloud.net.cn/plugin?id=28) type 属性） * @property {String} leftIconWidth （扩展属性）左侧按钮区域宽度 用来满足设计稿要求 * @property {String} rightIconWidth （扩展属性）右侧按钮区域宽度 用来满足设计稿要求 * @property {String} color 图标和文字颜色 * @property {String} backgroundColor 导航栏背景颜色 * @property {Boolean} fixed = [true|false] 是否固定顶部 * @property {Boolean} holdPlace = [true|false] （扩展属性）固定在顶部时，是否需要占位 * @property {Boolean} opacity = 0-1 （扩展属性）头部透明度 用于头部滚动渐变 * @property {Boolean} statusBar = [true|false] 是否包含状态栏 * @property {Boolean} shadow = [true|false] 导航栏下是否有阴影 * @property {Boolean} border = [true|false] 导航栏下是否有边框线 * @event {Function} showLeftBack （扩展属性）是否显示返回按钮 * @event {Function} clickLeftBack （扩展属性）点击左侧区域是否关闭当前窗口 */export default { name: &quot;NavBar&quot;, props: { title: { type: String, default: &quot;&quot; }, leftText: { type: String, default: &quot;&quot; }, rightText: { type: String, default: &quot;&quot; }, leftIcon: { type: String, default: &quot;&quot; }, leftIconWidth: { type: String, default: &quot;132rpx&quot; }, rightIcon: { type: String, default: &quot;&quot; }, rightIconWidth: { type: String, default: '132rpx' }, fixed: { type: [Boolean, String], default: false }, holdPlace: { type: Boolean, default: true }, color: { type: String, default: &quot;#000000&quot; }, opacity: { type: [String,Number], default: &quot;1&quot; }, backgroundColor: { type: String, default: &quot;#FFFFFF&quot; }, statusBar: { type: [Boolean, String], default: false }, shadow: { type: [String, Boolean], default: false }, border: { type: [String, Boolean], default: true }, clickLeftBack: { // 点击返回按钮区域是否返回上一页/路由 type: [String, Boolean], default: true }, showLeftBack: { type: [Boolean, String], default: true } }, data() { return { showIconBg: false, // 是否显示按钮的背景色 showHome: false, // 是否显示回到首页按钮 showNavBar: true, headerHeight: CustomNavbarHeight + 'px', // 头部高度，默认是40 subHeaderHeight: '' // 子头部高度 } }, watch: { color() { this.handleColorChange() } }, created() { this.handleColorChange() }, mounted() { if(uni.report &amp;&amp; this.title !== '') { uni.report('title', this.title) } this.updateHeight() // #ifdef MP-WEIXIN this.judgeHome() // #endif }, updated() { this.updateHeight() }, methods: { updateHeight() { this.getSubHeaderHeight() this.getHeight() }, handleColorChange() { let color = this.color &amp;&amp; this.color.toLocaleLowerCase() // 只有背景色透明才设置按钮的背景颜色 let bgTransparent = this.backgroundColor == 'transparent' || this.backgroundColor == 'inherit' // 设置状态栏字体颜色 if (color &amp;&amp; (color === '#ffffff' || color === '#fff')) { uni.setNavigationBarColor({ frontColor: '#ffffff', backgroundColor: 'transparent' }) if (bgTransparent) this.showIconBg = true } else { uni.setNavigationBarColor({ frontColor: '#000000', backgroundColor: 'transparent' }) this.showIconBg = false } }, /** * 获取节点offset值 （而非小程序提供的相对可视窗口的offset值） * @param {string} selector 节点 与 select()方法一致 * @param {string} parent 节点相对滚动节点，非必传，不传以 viewport为默认值 * @param {string} context 查询上下文（页面/组件实例），含有自定义组件的页面，或者自定义组件中调用，必传 */ getOffset(selector, parent, context) { let query = context ? context.createSelectorQuery() : uni.createSelectorQuery(); let parentQuery = parent ? query.select(parent) : query.selectViewport() query.select(selector).boundingClientRect() parentQuery.scrollOffset() return new Promise((resolve, reject) =&gt; { query.exec(([selectRect, parentRect]) =&gt; { if (selectRect) { resolve({ top: selectRect.top + parentRect.scrollTop, left: selectRect.left + parentRect.scrollLeft, height: selectRect.height, width: selectRect.width, bottom: selectRect.bottom }) } else { console.warn(`[mp::getOffset]: 获取目标元素${selector}的offset信息失败`) resolve({ top: 0, left: 0, height: 0, width: 0 }) } }) }) }, async getSubHeaderHeight() { let subHeaderOffset = await this.getOffset('.uni-navbar__sub-header', null, this) this.subHeaderHeight = subHeaderOffset.height + 'px' }, async getHeight() { let navOffset = await this.getOffset('.uni-navbar__content', null, this) return navOffset }, // #ifdef MP-WEIXIN /** * 判断是否需要显示home按钮（只有小程序需要） **/ judgeHome() { // 页面栈栈顶，且路径为非首页，则显示home按钮 let pages = getCurrentPages() if ((pages.length &lt;= 1) &amp;&amp; HOME_PATH !== pages[0].route) { this.showHome = true } }, goHome() { uni.reLaunch({ url: '/'+HOME_PATH, }) }, // #endif onClickLeft() { if (this.clickLeftBack) { uni.navigateBack() } else { this.$emit(&quot;clickLeft&quot;); } }, onClickRight() { this.$emit(&quot;clickRight&quot;); } }};&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt; $nav-height: 44px; .uni-nav-bar-text { font-size: $uni-font-size-lg; } .uni-nav-bar-right-text { font-size: $uni-font-size-base; } .uni-navbar { position: relative; width: 100%; font-family: PingFangSC-Medium, PingFang SC; box-sizing: border-box; } .uni-navbar__content { position: relative; width: 100%; background-color: $uni-bg-color; } .uni-navbar__content_view { display: flex; align-items: center; flex-direction: row; } .uni-navbar__header { display: flex; flex-direction: row; width: 100%; height: $nav-height; line-height: $nav-height; font-size: 32rpx; } .header-icon-with-bg { display: flex; justify-content: center; align-items: center; align-content: center; background: rgba($color: #000000, $alpha: 0.2); border-radius: 100%; height: 52rpx; width: 52rpx; } .uni-navbar__header-btns { display: flex; flex-wrap: nowrap; padding: 0 12px; justify-content: center; align-items: center; box-sizing: border-box; } .uni-navbar__header-btns-left { display: flex; box-sizing: border-box; justify-content: flex-start; } .uni-navbar__header-btns-right { display: flex; box-sizing: border-box; justify-content: flex-end; margin-right: 10rpx; } .uni-navbar__header-container { flex: 1; font-weight: 600; } .uni-navbar__header-container-inner { display: flex; flex: 1; align-items: center; justify-content: center; font-size: $uni-font-size-base; } .uni-navbar__placeholder-view { height: $nav-height; box-sizing: content-box; } .uni-navbar--fixed { position: fixed; z-index: 998; } .uni-navbar--shadow { box-shadow: 0 1px 6px #ccc; } .uni-navbar--border { border-bottom-width: 1rpx; border-bottom-style: solid; border-bottom-color: $uni-border-color; }&lt;/style&gt;","link":"/2020/11/20/uni-app/com-nav-bar/"},{"title":"uni-app 小程序状态栏组件","text":"小程序状态栏高度通过wx.getSystemInfoSync().statusBarHeight获取是最准确的。单位是px。wx.getMenuButtonBoundingClientRect()方法获取的top属性时不准确的，不能作为参考。 12345678910111213141516171819202122232425&lt;template&gt; &lt;view :style=&quot;{ height: statusBarHeight }&quot; class=&quot;uni-status-bar&quot;&gt; &lt;slot /&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;const statusBarHeight = uni.getStatusBarHeight()export default { name: 'status-bar', data() { return { statusBarHeight: statusBarHeight + 'px' } }}&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt; .uni-status-bar { width: 750rpx; height: 20px; }&lt;/style&gt;","link":"/2020/11/20/uni-app/com-status-bar/"},{"title":"uni-app H5模式下treeShaking的坑","text":"uni-apph5打包模式，使用treeShaking时，该配置只在生产模式下有效，即使部署到测试和预生产都没有问题，发布到生产之前一定要先本地打包生产模式确保无异常。 我们的项目发布到生产之后运行h5出现以下报错： 经过一番全局搜索，看到了一个插件（目录：@dcloudio/vue-cli-plugin-uni-optimize/packages/babel-plugin-uni-api/index.js）： 1234567891011121314151617181920process.UNI_APIS = new Set()module.exports = function ({ types: t}) { return { visitor: { MemberExpression (path, state) { if ( t.isIdentifier(path.node.object) &amp;&amp; ( path.node.object.name === 'uni' || path.node.object.name === 'wx' ) ) { process.UNI_APIS.add(path.node.property.name || path.node.property.value) } } } }} 该插件在获取了AST语法树之后，将遇到uni.xxx语法的对象属性引用对应的api名称添加到process.UNI_APIS中。 然而，通过调试发现代码并没有运行到此处，此路不通。 后来终于发现了一个关键线索。 读取optimization.treeShaking开关并标记 @dcloudio/vue-cli-plugin-uni/lib/env.js文件中读取到optimization.treeShaking配置为true时，就会执行以下代码： 1process.env.UNI_OPT_TREESHAKINGNG = true vue-cli-optimize插件 vue-cli-plugin-uni-optimize插件（@dcloudio/vue-cli-plugin-uni-optimize/index.js）针对uni-api做了以下事情： 将process.UNI_APIS写入@dcloudio\\vue-cli-plugin-uni-optimize.tmp\\api.js路径下的文件 将uni api的模块引用路径替换成@dcloudio\\vue-cli-plugin-uni-optimize.tmp\\api.js路径下的文件 但是我们从前文可知，唯一一处更新process.UNI_APIS的代码并未执行（猜测是uni-app代码的bug），导致uni-api update了个寂寞: 以上关键代码并未更新任何api，只是引入了一些默认的核心api（@dcloudio/vue-cli-plugin-uni-optimize/packages/webpack-optimize-plugin/api.js）: 以上代码标记部分，manifest[name][2]的值为true，即为核心api时才会被默认引入。 由于不知道什么原因没有使用babel-plugin-uni-api，而且，考虑到该插件的tree-shaking比较粗暴，增加了业务代码的开发复杂度。 而我负责的项目，业务中存在对uni的直接使用扩展运算符来实现uni-api和其它自定义api的整合： 1234sdk = { ...uni, someCustomApi: function(){...}} 即使babel-plugin-uni-api插件正常工作，根据该插件的shaking原理，我们需要将扩展运算符改为按需赋值的结构： 12345sdk = { api1: uni.api1, api2: uni.api2, someCustomApi: function(){...}} 每增加一个新的uni-api都要去修改sdk文件，这是开发不希望发生的事情。因此考虑简单粗暴从manifest.json文件入手，让每一个api都成为核心api。在compiler的beforeCompile钩子回调中修改manifest文件的标记： 12345678910111213const manifest = require('@dcloudio/uni-h5/manifest.json')Object.keys(manifest).forEach(name =&gt; { if (manifest[name].length &lt; 3) { manifest[name].push(true) }})const newManifest = JSON.stringify(manifest, null, 2);try { fs.writeFileSync(path.resolve(process.cwd(), 'node_modules', '@dcloudio/uni-h5/manifest.json'), newManifest) console.log('@dcloudio/uni-h5/manifest.json 替换成功...')} catch (err) { console.log('@dcloudio/uni-h5/manifest.json 替换失败...')} writeFileSync将json写回文件时，需要转化为字符串，为了让字符串能够换行，保持json格式，需要传入JSON.stringify的第三个参数值为2，表示保留换行和空格，以及每次缩进使用2个空格。 结果将“未开启tree-shaking”，“开启tree-shaking打包异常”，“开启tree-shaking并修复api打包异常”3个版本打包结果对比： 可以看到，uni-app的tree-shaking效果一般，修复tree-shaking的打包结果依旧比开启前少了0.1M。 uni-app 2.2 大幅优化H5端性能体验，只开发H5，也要用uni-app这篇文章提到，manifest内部的的tree-shaking其实主要做了2件事，内置组件的treeShaking和api的treeShaking，而且，文中数据显示，shaking效果拔群。但是本人尝试的结果发现效果实在一般。","link":"/2021/05/10/uni-app/h5-tree-shaking/"},{"title":"defineProperty","text":"定义了如下一个对象： 123456789101112let arr = { a: []}Object.defineProperty(arr, 'a', { get() { console.log('get') return [] }, set(val) { console.log('set') }}) 当执行arr.a = [1, 2]时输出 1set 当执行arr.a.push(1)或者arr.a[0] = 1时输出 1get 这说明，Array的元素的增减不会触发setter。 那，为什么在 Vue中，arr.a[0] = 1不会触发视图更新，但是arr.a.push(1)却可以呢。 Vue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括： push, pop, shift, unshift, splice, sort, reverse 截取核心的代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/* observer/array.js */import { def } from '../util/index'const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)[ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) { // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) { // 执行默认行为 original: Array.prototype[method] const result = original.apply(this, args) // ob: Observer实例 const ob = this.__ob__ // 获取数组中新增的元素，并为其添加watcher let inserted switch (method) { case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break } if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result })})// ------------------------------------- ///* util/lang.js *//** * Define a property. */export function def (obj: Object, key: string, val: any, enumerable?: boolean) { Object.defineProperty(obj, key, { value: val, enumerable: !!enumerable, writable: true, configurable: true })}// ------------------------------------- ///* observer/index.js */import { arrayMethods } from './array'function protoAugment (target, src: Object, keys: any) { target.__proto__ = src}function copyAugment (target: Object, src: Object, keys: Array&lt;string&gt;) { for (let i = 0, l = keys.length; i &lt; l; i++) { const key = keys[i] def(target, key, src[key]) }}// ...export class Observer { value: any; dep: Dep; vmCount: number; // number of vms that has this object as root $data constructor (value: any) { this.value = value this.dep = new Dep() this.vmCount = 0 def(value, '__ob__', this) if (Array.isArray(value)) { const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) this.observeArray(value) } else { this.walk(value) } } // ... /** * Observe a list of Array items. */ observeArray (items: Array&lt;any&gt;) { for (let i = 0, l = items.length; i &lt; l; i++) { observe(items[i]) } }} 输出挂载在Vue实例上的数组和未挂载在Vue实例上的数组进行比较： 1234567891011121314151617181920&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;new Vue({ data: { arr: [1, 2] }, created() { console.log('arr on vue:', this.arr) console.log('arr free:', [1, 2]) }})&lt;/script&gt;&lt;/html&gt; 输出对比： 可以看出来，挂载在vue实例上的数组，原型是arrayMethods，arrayMethods继承于Array。 上面输出的结果说明了什么？只有调用了数组上的’push’,’pop’,’shift’,’unshift’,’splice’,’sort’,’reverse’方法，才能触发watcher更新DOM。 可运行下面的代码以做验证： 12345678910111213141516171819202122232425262728293031&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-for=&quot;number in arr&quot;&gt; {{number}} &lt;/div&gt; &lt;button @click=&quot;push&quot;&gt;push&lt;/button&gt; &lt;button @click=&quot;rawPush&quot;&gt;rawPush&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt;new Vue({ el: '#app', data: { arr: [1, 2] }, methods: { push() { this.arr.push('3') }, rawPush() { Array.prototype.push.apply(this.arr, [4]) } }})&lt;/script&gt;&lt;/html&gt; 上面的代码中，push方法执行后视图立即更新。rawPush方法执行后视图没有更新，但是内容有push成功。下次执行push方法才会把rawPush进去的值渲染出来。 为什么有时候直接对数组的某个元素赋值却发现有更新呢？ 原因是存在搭便车的情况。请看如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;changeArr&quot;&gt;修改arr&lt;/button&gt; &lt;button @click=&quot;changeProp&quot;&gt;修改prop&lt;/button&gt; &lt;button @click=&quot;changeBoth&quot;&gt;一起修改&lt;/button&gt; &lt;div&gt;arr:&lt;/div&gt; &lt;div v-for=&quot;(item, $index) in arr&quot; :key=&quot;$index&quot;&gt;{{item}}&lt;/div&gt; &lt;div&gt;&lt;br&gt;prop:&lt;/div&gt; &lt;div&gt;{{JSON.stringify(prop)}}&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { arr: [1, 2], prop: { a: { b: { c: '' } } } } }, methods: { changeProp() { this.prop.a.b.c = 'hello' }, changeArr() { this.arr[0] = 111 }, changeBoth() { this.changeProp() this.changeArr() } }}&lt;/script&gt; 对数组的某个元素直接修改，视图不会先更新，除非在修改之后其它因素触发了视图更新。 假如，prop属性没有渲染在视图中，那么，点击任何一个按钮都不会刷新视图。","link":"/2019/11/03/vue/define-property/"},{"title":"vue 的mount 过程","text":"前段时间学习了vue的源码，理清了vue的mount流程，在此做下总结。 mount过程分为2个大阶段，生成vnode，和渲染dom 生成vnodemount方法其实调用了render函数，该函数返回的就是vnode 渲染 dom这个过程主要调用了update方法。每一个vnode的渲染都会调用一次update方法。 针对组件，render返回的对应vnode只是一个占位vnode。在update的时候占位vnode会根据组件配置生成所有内容的dom。 渲染过程其实是一个深度遍历的过程。即，最先生成子dom，逐个层级向上插入，直到插入根结点的dom中。","link":"/2020/04/02/vue/mount-flow/"},{"title":"一次bug引出的关于vue 的节点复用的思考","text":"vue使用v-for时会要求绑定key属性，这个涉及到vue的节点复用的功能。 其实，你有没有发现，其实我们可能一直没有搞清楚究竟它是什么样的复用逻辑。 现在，我们分别从官方文档和源码的角度给予分析。 什么情况下会复用节点为什么v-for渲染的文本节点内容没有复用，但是图片节点被复用","link":"/2020/08/25/vue/node-reuse/"},{"title":"常见的vue 报错信息","text":"模板渲染初始化问题1Proxy.render Cannot read property '0' of undefined 上面这个报错是指在构建DOM的时候，有个变量是undefined，但是这个变量被当成Array类型并访问了下标值。 这种情况通常出现在数据初始化的时候，某些属性不存在，但是访问了这个不存在的属性的子属性 计算属性绑定v-model1Computed property &quot;&quot; was assigned to but it has no setter. 通常这个报错的原因是，用一个计算属性绑定到v-model上面。 1234567891011121314// template部分&lt;el-rate v-model=&quot;rate&quot; disabled&gt;&lt;/el-rate&gt;// js部分computed: { rate() { if (this.detail) { return parseFloat(this.detail.starRating) || 0 } else { return 0 } } } 解决办法 尽量避免计算属性用在v-model上，因为计算属性一般是通过现有的值计算出来的。如果可以通过其它方式修改计算属性的话，数据状态会比较混乱。 计算属性默认是只有getter的，就是说只能取值，不能设值。computed支持手动添加set函数。具体参考vue 计算属性","link":"/2020/07/09/vue/vue-error/"},{"title":"vue runtime 和 esm","text":"一. esm是vue 的“运行时”和“编译器”的集合运行时运行时是用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。 编译器用来将模板字符串编译成为 JavaScript 渲染函数的代码。 在客户端编译模板包含以下情况： el属性指定模版挂载的DOM，和该DOM包含的html，也就是说，既没有指定template，又没有render函数 用template属性指定模板渲染的字符串 如何选择vue的package.json文件中的module属性指定了模块的入口文件为vue.runtime.esm.js，为什么呢，因为这个只包含了运行时，不包含编译器。相比全部包含的vue.esm.js文件而言，vue.runtime.esm.js体积小了将近三分之一，初始化运行速度相对来说会高一些。 我发现，在开发单页应用的时候，绝大多数情况下可以避免出现使用编译器的情况，所以，我只说下我遇到的情况。 通常，我们的单页应用的入口html，入口文件和顶级组件分别是index.html, main.js和App.js。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- main.js --&gt;import Vue from 'vue'import App from './App'Vue.config.productionTip = falsenew Vue({ el: '#app', template: '&lt;App/&gt;', components: {App}})&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div&gt; HelloWorld &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'App'}&lt;/script&gt; 就像上面这种情况，初始化根实例的时候，用template指定了挂载元素，这就意味着，一定要用编译器。如果你的webpack.config.js里面没有设置vue的alias，并且，在main.js文件中，直接使用import Vue from ‘vue’，你会发现，浏览器会报错: 1[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build. 但是，如果你把 1import Vue from 'vue' 改成 1import Vue from 'vue/dist/vue.esm.js' 就会运行正常。不知道有多少项目都只是因为这个根实例导致不得不引入vue.esm.js。 那么，针对这个情况怎么解决呢？想必很多人都知道答案了。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- main.js --&gt;import Vue from 'vue'import App from './App'Vue.config.productionTip = falsenew Vue({ el: '#app', render(h) { return h(App) }})&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div&gt; HelloWorld &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'App'}&lt;/script&gt; 其实只改了一行代码，就是把main.js中的template替换成render函数。之前发现有的项目用render有的直接template，现在才知道是这么回事。 二. esm和common什么关系，为什么除了runtime.esm和esm之外，还有vue.common.js和vue.js呢？1. esm全称是ESModule，意思是遵循es6的import export模块化规则。2. common的意思是遵循common.js的exports模块化规则。3. 如何选择?我们知道common.js的模块化是输出一个exports对象，没法做到按需引入，一旦引入，就是用 require引入整个exports对象。但是ES6的import 可以选择引入哪些属性。 前者是运行时引入，后者是编译时引入（NodeJS打包）。由于编译时即可知道哪些是没有用到的，这样就可以达到tree shaking的目的（通过webpack配合达到）。 esm.js文件里面是符合ES6模块规则的es5的语法，是经过babel编译过的。为什么要是es5的语法呢？一般情况下业务代码在使用babel-loader的时候会exclude掉node_module目录，这是因为，node_module目录里面有大量的源代码，处理起来很浪费时间，所以干脆模块开发者帮你编译好，别人直接用你编译好的，而且能tree shaking的代码版本即可。","link":"/2020/08/01/vue/vue-runtime-compile/"},{"title":"项目静态资源CDN服务无响应情况的回源","text":"背景某日，华为云上部署的cdn服务故障导致部分区域静态资源（js和css）响应超时。这种情况是我们没有预料到的，幸亏用户不多，否则需要紧急发版将静态资源指向源服务器。 我们的项目采用uni-app框架开发，内部基于vue-cli。生产模式会使用publicPath配置将静态资源指向cdn服务器，即，代码经过webpack编译后资源引用地址就已经固定了。 任务拆解为了应对以上情况，我们需要实现一种机制，能够识别cdn异常，并切换资源为源服务器。 我们的任务分为以下： publicPath运行时全局变更 cdn资源请求异常识别方法 资源开关切换机制 方案分析与实施publicPath运行时全局变更经过分析打包后的模块代码： 123456/******/ function jsonpScriptSrc(chunkId) {/******/ return __webpack_require__.p + &quot;static/js/&quot; + ({&quot;project-qlymain-pages-404&quot;:&quot;project-qlymain-pages-404&quot;}[chunkId]||chunkId) + &quot;.&quot; + {&quot;chunk-0826ee9b&quot;:&quot;964d9183&quot;,&quot;chunk-69a5a22c&quot;:&quot;9e1c8209&quot;,&quot;project-qlymain-pages-404&quot;:&quot;330de720&quot;}[chunkId] + &quot;.js&quot;/******/ }/******/ ....此处省略一些中间代码/******/ // __webpack_public_path__/******/ __webpack_require__.p = &quot;/&quot;; 以及webpack源码： 123456789this.hooks.requireExtensions.tap(&quot;MainTemplate&quot;, (source, chunk, hash) =&gt; { const buf = []; const chunkMaps = chunk.getChunkMaps(); // ... // ... buf.push(&quot;// __webpack_public_path__&quot;); buf.push(`${this.requireFn}.p = ${JSON.stringify(publicPath)};`); return Template.asString(buf);}); 可以发现，publicPath被写入模块属性__webpack_require__.p上，我只需要修改这个属性值就可以了。 一开始我写了个插件，通过拦截compiler钩子修改这个模块属性： 12345678910111213141516function pushBuff(valName, defaultVal, source) { var buf = []; buf.push(source); buf.push(''); buf.push('// Dynamic assets path override (/build/plugins/runtime-publicpath-plugin)'); buf.push(`__webpack_require__.p = ${valName} || '${defaultVal}'`); return buf.join('\\n');}// ...if (compiler.hooks &amp;&amp; compiler.hooks.thisCompilation) { compiler.hooks.thisCompilation.tap('RuntimePublicpathPlugin', function (compilation) { compilation.mainTemplate.hooks.requireExtensions.tap('RuntimePublicpathPlugin', function (source, chunk, hash) { return pushBuff(globalVariable, defaultPublicPath, source) }) });} 但是，这个插件的目的是覆盖__webpack_require__.p的值为runtime的运行时全局变量（window[globalVariable]），但是我们的开关状态可能要存储到localstorage中（因为要实现状态缓存），而且存进去的字段名由业务代码决定，这样就导致插件和业务过渡耦合。 后来发现业务代码中可以使用webpack提供的变量webpack_public_path，webpack会在编译时将这些变量替换成__webpack_require__.p。 至此，我们找到了publicPath运行时的覆盖方法： 1__webpack_public_path__ = localstorage.getItem('__webpack_public_path__') 异步资源加载打包后按需加载的代码： 1234567891011121314// script path functionfunction jsonpScriptSrc(chunkId) { return __webpack_require__.p + &quot;&quot; + ({ &quot;project-qlymall-views-order-logisticsDetail&quot;:&quot;project-qlymall-views-order-logisticsDetail&quot;, &quot;project-qlymall-views-order-refundDetail&quot;:&quot;project-qlymall-views-order-refundDetail&quot; // ...... }[chunkId]||chunkId)+'.js'}// ......// 创建script标签/******/ var script = document.createElement('script');/******/ // ....../******/ script.src = jsonpScriptSrc(chunkId);/******/ 为了使我们的开关机制生效，需要保证jsonpScriptSrc方法在publicPath变更后执行。实施发现只要将以下语句放在入口文件最顶部执行即可。 1__webpack_public_path__ = localstorage.getItem('__webpack_public_path__') 插入index.html的cdn标签需要重写处理完异步加载的资源，我们还要处理入口index.html的资源。vue-cli内部使用了html-webpack-plugin将所有的assets插入了index.html中，包括pulicPath： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://mycdn.mycompany.com/static/index.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=https://mycdn.mycompany.com/static/js/index.bd9cfc6f.js&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 如何处理这种情况呢？有2个思路。 本着解决问题不如绕开问题的原则，考虑入口文件代码直接内联 入口文件也使用异步加载的方法 针对方案1，看起来很简单粗暴，但是会产生一个问题：index.html使用的是源站资源，而非cdn。index.js一般代码比较大，如果内联是不是本身就违背了cdn的初衷呢？所以最终我们采用了方案2。 入口文件异步加载让入口文件异步加载的方法，一开始想到的方案是，写插件，覆盖vue-cli使用html-webpack-plugin的默认行为，替代为动态插入script标签的逻辑，这段代码由于不经过babel，所以语法需要谨慎。想想这样做有点大费周章了。 后来发现可以直接覆盖掉入口文件，我们称之为main2.js，该文件关键代码： 1234/* 加载主入口文件 */import('@/main.js').catch(err =&gt; { handleError(err)}) 这样就巧妙实现了入口文件异步加载。那么问题来了，main2.js又会被html-webpack-plugin插入index.html。由于main2.js的代码量较少，我选择内联，使用HtmlWebpackInlineSourcePlugin将main.js内联到index.html中。 index.css的处理在调试HtmlWebpackInlineSourcePlugin的过程中发现，index.css并不在assets列表中。我们看看index.css的生成代码： 这段代码做了2件事： 通过检查html中有没有VUE_APP_INDEX_CSS_HASH来判断生辰的index.css文件名要不要带上hash 将@dcloudio/uni-h5/dist/index.css文件中的内容取出来再加工，用copyWebpackPlugin插件将文件粘贴到dist目录中。 鉴于该文件不大，可以选择内联或者在main2.js中动态插入link标签。我选择了后者。 既然选择了动态插入link标签，就要知道，index.[hash].css的文件名，如何在运行时知晓呢？很简单，使用definePlugin将VUE_APP_INDEX_CSS_HASH注入运行时即可。 cdn加载异常识别一开始想到的是使用window.addEventListener(‘error’)，但是尝试后发现无法捕获promise中的异常，所以改用window.addEventListener(‘unhandledrejection’)。 在回调中，需要做判断区分是否是资源加载超时。通过分析webpack模块源码可以发现它有做超时异常处理： 且超时时间可以通过output.chunkLoadTimeout配置修改，默认值是120s，觉得太长的可以考虑覆盖。对于现在的用户来说，12s都算很长了，所以我选择缩短到12s。此外，超时异常格式可以通过上图的type和message匹配。 cdn开关切换针对开关切换，一开始想到的方案是通过接口变更开关状态，但是这样存在以下问题： 简单的开关可以通过人为控制apollo字段实现，但是无法感知客户端异常。开发者需要实现一个客户端告警机制触发开关变更，实现成本较高。 开关属于全局性的，一旦切换到源服务器，将会对源服务器造成较大压力。 后来选择客户端自行切换开关的方案： 识别到cdn加载超时之后，我们业务的处理逻辑是：切换开关，将开关缓存5min，缓存的原因是，我们的业务属于APP内嵌h5，每个窗口都会重新初始化，所以需要窗口之间开关状态共享。 难点清单 找到动态资源拼接的代码，找到__webpack_require__.p，如何重写它，使得运行时可修改index.css处理 内联？还是动态插入的选择 index.css文件名有hash怎么办","link":"/2021/05/27/webpack/cdn-switch/"},{"title":"凹槽样式小结","text":"border-radius由于border-radius的最大半径是50%，无法直接实现大弧度。独立一个元素，使其尺寸是容器的1倍以上，再通过平易即可实现视觉上的凹槽效果。 123456789101112131415161718&lt;!--html--&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;curved-bg&quot;&gt;&lt;/div&gt;&lt;/div&gt;// css.container { width: 300px; height: 300px; overflow: hidden;}.curved-bg { width: 300%; height: 300%; margin-top: -250%; margin-left: -100%; border-radius: 50%; background-color: rgba(0, 0, 0, 0.3);} curved border-radius以上方法只是对一个简单的背景做圆角处理。针对以下场景，圆弧部分只是一个修饰，图片部分的轮播图可点击交互。 可以通过椭圆圆角实现： 123456789101112131415161718&lt;!--html--&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;curved-bg2&quot;&gt;&lt;/div&gt;&lt;/div&gt;// css.container { width: 300px; height: 300px; overflow: hidden;}.curved-bg2 { height: 100%; margin-top: -50%; background-color: rgba(0, 0, 0, 0.3); /* Curved corners */ border-bottom-left-radius: 50% 10%; border-bottom-right-radius: 50% 10%;} 利用了border-radius的裁剪形状。具体参考border-top-left-radius 以上2种方法渲染结果对比： 前者的效果两端较为平缓，而curved border-radius的两端比较陡峭，接近于垂直。 切图从上面的对比结果来看，curved border-radius无法很好的实现我们想要的效果，那么，还有一个简单的办法，就是将有弧度的部分切成一张png图盖在banner上。 搞了半天还是这个办法最简单啦。 水波纹效果在寻找方案的时候看到了一个有意思的水波纹。 实现原理就是多个方形容器旋转。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;div class=&quot;wave&quot;&gt; 水波纹效果 &lt;div class=&quot;wave1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;wave2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;wave3&quot;&gt;&lt;/div&gt;&lt;/div&gt;.wave{ position: relative; border: 1px solid silver; width: 100px; height: 100px; border-radius: 50%; line-height: 50px; margin: 0 auto; font-size: 14px; text-align: center; overflow: hidden; animation: water-wave linear infinite;}.wave1{ position: absolute; top: 40%; left: -25%; background: #33cfff; opacity: .7; width: 200%; height: 200%; border-radius: 40%; animation: inherit; animation-duration: 5s;}.wave2{ position: absolute; top: 40%; left: -35%; background: #0eaffe; opacity: .7; width: 200%; height: 200%; border-radius: 35%; animation: inherit; animation-duration: 7s;}.wave3{ position: absolute; top: 50%; left: -35%; background: #0f7ea4; opacity: .3; width: 200%; height: 200%; border-radius: 33%; animation: inherit; animation-duration: 11s;}@keyframes water-wave{ 0% {transform: rotate(0deg);} 100% {transform: rotate(360deg);}}","link":"/2021/06/02/css/curved-radius/"},{"title":"webpack中的chunk和bundle","text":"chunk是webpack运行时的概念，bundle是webpack的执行结果，即生成了多少个文件。 chunk和entry一个entry对应一个chunk。chunk属于一个webpack构建过程中的概念。一个entry对应一个依赖树，这个依赖树所有依赖的集合就是一个chunk。 原始条件下，每个chunk对应生成一个bundle。 如果多个entry之间存在包含关系，则可能一个bundle打包多个chunk。 1234entry: { index: './src/index.js', add: './src/add.js'}, index引用了add.js。最终的打包结果，index.js中包含了chunk 0，即出现了重复打包。 1234567891011121314Hash: 8471c9024ea2740e855fVersion: webpack 4.46.0Time: 3338msBuilt at: 2021-06-02 11:59:15 AM Asset Size Chunks Chunk Names add.js 987 bytes 0 [emitted] addindex.js 72.5 KiB 1, 0 [emitted] indexEntrypoint index = index.jsEntrypoint add = add.js[0] ./src/add.js 49 bytes {0} {1} [built][1] ./node_modules/lodash/lodash.js 531 KiB {1} [built][2] ./src/index.js 89 bytes {1} [built][3] (webpack)/buildin/global.js 472 bytes {1} [built][4] (webpack)/buildin/module.js 497 bytes {1} [built] sourcemap和chunksoucemap选项如果不含inline，则会针对每个bundle生成生成一个map文件。 同名js文件和map文件同属于一个chunk。 runtimechunk它的作用是将包含chunks 映射关系的 list单独从 app.js里提取出来，因为每一个 chunk 的 id 基本都是基于内容 hash 出来的。 想一下这个场景，app.js-&gt;about.js。about因为某种原因（如按需加载）被打包为单独的bundle。每次about变化，就意味着about的hash变化，app.js中存在对about.js的引用路径，进而导致app.js也变化。 单独抽离 runtimeChunk 之后，每次打包都会生成一个runtimeChunk.xxx.js，其实这个文件非常的小，gzip 之后一般只有几 kb，但这个文件又经常会改变，我们每次都需要重新请求它，它的 http 耗时远大于它的执行时间了，所以建议不要将它单独拆包，而是将它内联到我们的 index.html 之中(index.html 本来每次打包都会变)。可以使用 inline-manifest-webpack-plugin或者 assets-webpack-plugin等来实现内联的效果。 runtimeChunk值为true或者’multiple’时会为每个entry生成1个文件。值为false时，所有的entry bundle共用一个chunk。 生成的runtime chunk需要插入index.html。 参考：webpack中的runtimeChunk spiltChunks该选项可以配置chunk之间的公共模块独立生成chunk，或者满足某些正则的模块独立出一个chunk。因此，该选项影响最终的bundle和chunk数目。 123456789101112131415161718192021222324252627282930313233const path = require('path')module.exports = { mode: 'production', devtool: 'none', entry: { index: './src/index.js', add: './src/add.js' }, output: { filename: '[name].[contenthash:8].js', path: path.resolve(__dirname, 'dist') }, optimization: { runtimeChunk: true, minimize: false, splitChunks: { cacheGroups: { common: { chunks: 'initial', minChunks: 2, minSize: 0, name: 'common' }, vendor: { test: /node_modules/, chunks: 'initial', name: 'vendor', enforce: true } } } }} 以上配置生成结果如下： 1234567891011121314 Asset Size Chunks Chunk Names add.559b3164.js 81 bytes 1 [emitted] [immutable] add common.a3657c09.js 326 bytes 0 [emitted] [immutable] common index.56507b59.js 739 bytes 2 [emitted] [immutable] index runtime~add.a5423113.js 6.11 KiB 3 [emitted] [immutable] runtime~addruntime~index.626b59fe.js 6.11 KiB 4 [emitted] [immutable] runtime~index vendor.4939a6bb.js 533 KiB 5 [emitted] [immutable] [big] vendorEntrypoint index [big] = runtime~index.626b59fe.js common.a3657c09.js vendor.4939a6bb.js index.56507b59.jsEntrypoint add = runtime~add.a5423113.js common.a3657c09.js add.559b3164.js[0] ./node_modules/lodash/lodash.js 531 KiB {5} [built][1] ./src/add.js 49 bytes {0} [built][2] ./src/index.js 147 bytes {2} [built][3] (webpack)/buildin/global.js 472 bytes {5} [built][4] (webpack)/buildin/module.js 497 bytes {5} [built] add.559b3164.js和index.56507b59.js是由于entry生成的。 common.a3657c09.js和vendor.4939a6bb.js是由于splitChunks生成的。 runtimeadd.a5423113.js和runtimeindex.626b59fe.js是由于runtimeChunk: true生成的。","link":"/2021/06/02/webpack/chunk-bundle/"}],"tags":[],"categories":[{"name":"通用","slug":"通用","link":"/categories/%E9%80%9A%E7%94%A8/"},{"name":"css","slug":"css","link":"/categories/css/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"网络","slug":"网络","link":"/categories/%E7%BD%91%E7%BB%9C/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"H5","slug":"H5","link":"/categories/H5/"},{"name":"js","slug":"js","link":"/categories/js/"},{"name":"html","slug":"html","link":"/categories/html/"},{"name":"nuxt","slug":"nuxt","link":"/categories/nuxt/"},{"name":"思考","slug":"思考","link":"/categories/%E6%80%9D%E8%80%83/"},{"name":"uni-app","slug":"uni-app","link":"/categories/uni-app/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"webpack","slug":"webpack","link":"/categories/webpack/"}]}